<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>android智能指针(sp wp)原理分析 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一. 前言
Android的native代码使用C++编写的。C++最让程序员头疼的事情就是对象的管理，即动态内存的分配与释放。一方面C++的这种灵活性可以为编程带来更大的自由，另一方面这种自由也带来了一些风险，稍有不慎，就可能造成内存泄漏甚至是程序崩溃。Java语言有GC（垃圾回收）机制，可以让程序员不用考虑对象生命周期的管理，虽然这对程序性能会造成一定的损失。那么如何既能发挥C++的性能优势，">
<meta property="og:type" content="article">
<meta property="og:title" content="android智能指针(sp wp)原理分析">
<meta property="og:url" content="http://yoursite.com/2015/07/17/2015-07-17-androide699bae883bde68c87e99288sp-wpe58e9fe79086e58886e69e90/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一. 前言
Android的native代码使用C++编写的。C++最让程序员头疼的事情就是对象的管理，即动态内存的分配与释放。一方面C++的这种灵活性可以为编程带来更大的自由，另一方面这种自由也带来了一些风险，稍有不慎，就可能造成内存泄漏甚至是程序崩溃。Java语言有GC（垃圾回收）机制，可以让程序员不用考虑对象生命周期的管理，虽然这对程序性能会造成一定的损失。那么如何既能发挥C++的性能优势，">
<meta property="og:updated_time" content="2015-10-30T03:40:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="android智能指针(sp wp)原理分析">
<meta name="twitter:description" content="一. 前言
Android的native代码使用C++编写的。C++最让程序员头疼的事情就是对象的管理，即动态内存的分配与释放。一方面C++的这种灵活性可以为编程带来更大的自由，另一方面这种自由也带来了一些风险，稍有不慎，就可能造成内存泄漏甚至是程序崩溃。Java语言有GC（垃圾回收）机制，可以让程序员不用考虑对象生命周期的管理，虽然这对程序性能会造成一定的损失。那么如何既能发挥C++的性能优势，">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">John Doe</a></h1>
		</hgroup>

		
				


		
			<div id="switch-btn" class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div id="switch-area" class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags">标签云</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="mailto:123@123.com" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="/#" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/Java学习/" style="font-size: 20px;">Java学习</a> <a href="/tags/Java转载/" style="font-size: 13.33px;">Java转载</a> <a href="/tags/PS4/" style="font-size: 10px;">PS4</a> <a href="/tags/PSVITA/" style="font-size: 10px;">PSVITA</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/android/" style="font-size: 16.67px;">android</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">专注于前端</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">John Doe</a></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<a href="/" class="profilepic">
				<img lazy-src="/img/avatar.png" class="js-avatar">
			</a>
			<hgroup>
			  <h1 class="header-author"><a href="/" title="回到主页">John Doe</a></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags">标签云</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="mailto:123@123.com" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="/#" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-2015-07-17-androide699bae883bde68c87e99288sp-wpe58e9fe79086e58886e69e90" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/17/2015-07-17-androide699bae883bde68c87e99288sp-wpe58e9fe79086e58886e69e90/" class="article-date">
  	<time datetime="2015-07-16T21:37:02.000Z" itemprop="datePublished">2015-07-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      android智能指针(sp wp)原理分析
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>一. 前言</strong></p>
<p>Android的native代码使用C++编写的。C++最让程序员头疼的事情就是对象的管理，即动态内存的分配与释放。一方面C++的这种灵活性可以为编程带来更大的自由，另一方面这种自由也带来了一些风险，稍有不慎，就可能造成内存泄漏甚至是程序崩溃。Java语言有GC（垃圾回收）机制，可以让程序员不用考虑对象生命周期的管理，虽然这对程序性能会造成一定的损失。那么如何既能发挥C++的性能优势，又能让程序自动管理对象的生命周期呢。智能指针就是为此而生的。这里我们将讨论android系统中智能指针，也就是我们常见的sp（强指针）wp（弱指针）的实现原理。</p>
<p>智能指针的实现一般都采用引用计数技术的方案。Android智能指针实现方案既包括简单的引用计数技术，也包括了复杂的引用计数技术（强引用计数，弱引用计数）。智能指针相关代码的路径是（android 5.0）：</p>
<pre><code>system<span class="regexp">/core/</span>include<span class="regexp">/utils/</span>RefBase.h
system<span class="regexp">/core/</span>libutils/RefBase.cpp
system<span class="regexp">/core/</span>include<span class="regexp">/utils/</span>StrongPointer.h
</code></pre><p>三个文件都不大，却包含了Android系统强大的智能指针的实现，其中的几个模板类：LightRefBase、RefBase、sp、wp组成了Android智能指针的框架，前两个是引用计数基类，后两个是智能指针类。要说明的是：任何想要使用Android智能指针的类都必须继承或者间接继承于LightRefBase/RefBase这两个基类。下面将着重分析这几个模板类。</p>
<p>PS：下面帖的代码基本上都是精简过的，去除了一些用于Debug的代码，便于分析本质。</p>
<p><strong>二. LightRefBase</strong></p>
<p>首先来分析一下Android智能指针的轻量级实现LightRefBase，他的代码在RefBase.h中：</p>
<pre><code>template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;
<span class="title">class</span> <span class="title">LightRefBase</span>
</span>{
  <span class="keyword">public</span>:
    <span class="function">inline <span class="title">LightRefBase</span><span class="params">()</span> : <span class="title">mCount</span><span class="params">(<span class="number">0</span>)</span> </span>{ }
    <span class="function">inline <span class="keyword">void</span> <span class="title">incStrong</span><span class="params">(__attribute__((unused)</span>) <span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span> </span>{
    android_atomic_inc(&amp;mCount);
    }
    <span class="function">inline <span class="keyword">void</span> <span class="title">decStrong</span><span class="params">(__attribute__((unused)</span>) <span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span> </span>{
        <span class="keyword">if</span> (android_atomic_dec(&amp;mCount) == <span class="number">1</span>) {
            delete static_cast&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);
        }
    }
    <span class="comment">//! DEBUGGING ONLY: Get current strong ref count.</span>
    <span class="function">inline int32_t <span class="title">getStrongCount</span><span class="params">()</span> <span class="keyword">const</span> </span>{
        <span class="keyword">return</span> mCount;
    }

  <span class="keyword">protected</span>:
    inline ~LightRefBase() { }

 <span class="keyword">private</span>:
    mutable <span class="keyword">volatile</span> int32_t mCount;

};
</code></pre><p>类的声明和实现全都在这里了，简单来看，这个类包含了一个成员变量引用计数器mCount，两个用来维护引用计数器值的成员函数incStrong和decStrong。基类只是提供了引用计数的能力，要实现内存对象的自动回收，还必须配合智能指针类（也就是sp、wp）管理引用计数。这里不想过早地引入智能指针类，但是为了对LightRefBase如何配合智能指针完成内存的自动回收有个大概的理解，我们一起来对以下伪代码运行的过程进行脑补：</p>
<pre><code><span class="collection">{
    LightClass* pLightClass = new LightClass<span class="list">()</span><span class="comment">;</span>
    smart_ptr&lt;LightClass&gt; lsp = pLightClass;
    printf<span class="list">(<span class="string">"Light Ref Count: %d.\n"</span>, pLightClass-&gt;getStrongCount<span class="list">()</span>)</span><span class="comment">;</span>
}</span>
</code></pre><p>1.LightClass继承于LightRefBase，LightClass构造的时候调用父类LightRefBase的构造函数，mCount初始化为0。<br>2.smart_ptr是智能指针类，智能指针利用LightClass的指针pLightClass构造出lsp。为了利用LightRefBase中的引用计数器，smart_ptr类构造的过程中会调用LightRefBase的incStrong函数使mCount加1。<br>3.从大括号跳出后，局部变量lsp要析构，smart_ptr类的析构函数中会调用LightRefBase的decStrong函数使mCount减1，并判断mCount是否为0，若为0，直接调用delete释放LightClass类new出来的对象。</p>
<p>这样new出来的LightClass对象就不需要显示地调用delete来回收内存，而是通过智能指针利用引用计数来决定何时释放内存。以简单的引用计数技术方式实现的智能指针似乎够用了吧，为什么还有下面的复杂的引用计数技术方式实现的智能指针呢？因为LightRefBase没有办法解决对象间循环引用的情况。下面会给出示例。至此，只需要记住LightRefBase拥有一个引用计数器mCount和两个用来维护引用计数器值的函数incStrong/decStrong即可。</p>
<p><strong>三. RefBase</strong></p>
<p>RefBase比LightRefBase从名字上看少了Light，那应该复杂很多吧。看下RefBase类的声明：</p>
<pre><code><span class="keyword">class</span> RefBase
{
  <span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;

    <span class="function"><span class="keyword">void</span> <span class="title">forceIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;
    <span class="comment">//! DEBUGGING ONLY: Get current strong ref count.</span>
    <span class="keyword">int32_t</span>         getStrongCount() <span class="keyword">const</span>;
    <span class="keyword">class</span> weakref_type
    {
      <span class="keyword">public</span>:
        <span class="function">RefBase* <span class="title">refBase</span><span class="params">()</span> <span class="keyword">const</span></span>;

        <span class="function"><span class="keyword">void</span> <span class="title">incWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;
        <span class="function"><span class="keyword">void</span> <span class="title">decWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;

        <span class="comment">// acquires a strong reference if there is already one.</span>
        <span class="function"><span class="keyword">bool</span> <span class="title">attemptIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;

        <span class="comment">// acquires a weak reference if there is already one.</span>
        <span class="comment">// This is not always safe. see ProcessState.cpp and BpBinder.cpp</span>
        <span class="comment">// for proper use.</span>
        <span class="function"><span class="keyword">bool</span> <span class="title">attemptIncWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;

        <span class="comment">//! DEBUGGING ONLY: Get current weak ref count.</span>
        <span class="keyword">int32_t</span> getWeakCount() <span class="keyword">const</span>;

    };
    <span class="function">weakref_type*   <span class="title">createWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;
    <span class="function">weakref_type*   <span class="title">getWeakRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;
    <span class="keyword">typedef</span> RefBase basetype;

  <span class="keyword">protected</span>:
    RefBase();
    <span class="keyword">virtual</span> ~RefBase();
    <span class="comment">//! Flags for extendObjectLifetime()</span>
    <span class="keyword">enum</span> {
        OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,
        OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,
        OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span>
    };
    <span class="function"><span class="keyword">void</span> <span class="title">extendObjectLifetime</span><span class="params">(int32_t mode)</span></span>;
    <span class="comment">//! Flags for onIncStrongAttempted()</span>
    <span class="keyword">enum</span> {
        FIRST_INC_STRONG = <span class="number">0x0001</span>
    };

    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onFirstRef</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">onIncStrongAttempted</span><span class="params">(uint32_t flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;

  <span class="keyword">private</span>:
    <span class="keyword">friend</span> <span class="keyword">class</span> weakref_type;
    <span class="keyword">class</span> weakref_impl;

    RefBase(<span class="keyword">const</span> RefBase&amp; o);
    RefBase&amp;        <span class="keyword">operator</span>=(<span class="keyword">const</span> RefBase&amp; o);
    weakref_impl* <span class="keyword">const</span> mRefs;
};
</code></pre><p>RefBase类确实要复杂一些，他没有mCount，成员变量也只有一个weakref_impl类型的mRefs,看来这个mRefs就是实现引用计数的关键了。此外还有一些关键的控制引用计数的方法incStrong、decStrong、forceIncStrong、createWeak。weakref_type内部类，看起来和weakref_impl类型的mRefs有些关系。enum变量(OBJECT_LIFETIME_STRONG、OBJECT_LIFETIME_WEAK、OBJECT_LIFETIME_MASK)指示了维护对象引用计数所使用的策略，后面会解释他们的具体涵义。以onXXX开头的回调函数了，他们可以被继承于RefBase的子类重写。</p>
<p>和引用计数相关的变量mRefs是weakref_impl类型的，所以要先研究下这个weakref_impl类。他的定义在RefBas.cpp文件中。</p>
<pre><code><span class="keyword">class</span> RefBase::weakref_impl : <span class="keyword">public</span> RefBase::weakref_type
{
  <span class="keyword">public</span>:
    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mStrong;
    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mWeak;
    RefBase* <span class="keyword">const</span> mBase;
    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mFlags;

    weakref_impl(RefBase* base)
    : mStrong(INITIAL_STRONG_VALUE)
    , mWeak(<span class="number">0</span>)
    , mBase(base)
    , mFlags(<span class="number">0</span>)
    {
    }
};
</code></pre><p>weakref_impl类继承于weakref_type，从类名上看weakref_type是接口，weakref_impl是具体实现。但是去除了debug用的相关代码后，weakref_impl显得十分单薄，一些关键的方法（incWeak、decWeak、attemptIncStrong、attemptIncWeak）也还是在父类中实现的。不管怎样先专注于weakref_impl，他定义了以下变量，并在构造函数中初始化：</p>
<p>1.mStrong 强引用计数器<br>2.mWeak 弱引用计数器<br>3.mBase 指向外部类对象，也就是原始对象的指针<br>4.mFlags 控制引用计数使用策略，取值是RefBase中定义的enum值</p>
<p>和LightRefBase只有一个mCount引用计数器不同，RefBase定义了weakref_impl类型的mRefs变量，并持有mStrong强引用计数器和mWeak弱引用计数器，配合mFlags控制引用计数使用策略，为实现更为强大的智能指针奠定了基础。下面将介绍智能指针类sp、wp，一览Android智能指针的全貌。</p>
<p><strong>四. sp强指针</strong></p>
<p>前面介绍的LightRefBase和RefBase只是基类，他们提供了引用计数的能力，必须配合智能指针类，才能实现内存对象的自动管理。这里先介绍sp强指针，他的类声明在StrongPointer.h中：</p>
<pre><code>template&lt;typename T&gt;
<span class="keyword">class</span> <span class="title">sp</span> {
  <span class="keyword">public</span>:
    <span class="function">inline <span class="title">sp</span>(<span class="params"></span>) : <span class="title">m_ptr</span>(<span class="params"><span class="number">0</span></span>) </span>{ }
    sp(T* other);
    sp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other);
    template&lt;typename U&gt; sp(U* other);
    template&lt;typename U&gt; sp(<span class="keyword">const</span> sp&lt;U&gt;&amp; other);

    ~sp();

    <span class="comment">// Assignment</span>
    sp&amp; <span class="keyword">operator</span> = (T* other);
    sp&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> sp&lt;T&gt;&amp; other);
    template&lt;typename U&gt; sp&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> sp&lt;U&gt;&amp; other);
    template&lt;typename U&gt; sp&amp; <span class="keyword">operator</span> = (U* other);
    <span class="comment">//! Special optimization for use by ProcessState (and nobody else).</span>
    <span class="function"><span class="keyword">void</span> <span class="title">force_set</span>(<span class="params">T* other</span>)</span>;

    <span class="comment">// Reset</span>
    <span class="function"><span class="keyword">void</span> <span class="title">clear</span>(<span class="params"></span>)</span>;

    <span class="comment">// Accessors</span>
    inline T&amp; <span class="keyword">operator</span>* () <span class="keyword">const</span>  { <span class="keyword">return</span> *m_ptr; }
    inline T* <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span> { <span class="keyword">return</span> m_ptr;  }
    inline T* <span class="keyword">get</span>() <span class="keyword">const</span> { <span class="keyword">return</span> m_ptr; }

    <span class="comment">// Operators</span>
    COMPARE(==)
    COMPARE(!=)
    COMPARE(&gt;)
    COMPARE(&lt;)
    COMPARE(&lt;=)
    COMPARE(&gt;=)

  <span class="keyword">private</span>:
    template&lt;typename Y&gt; friend <span class="keyword">class</span> <span class="title">sp</span>;
    template&lt;typename Y&gt; friend <span class="keyword">class</span> <span class="title">wp</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">set_pointer</span>(<span class="params">T* ptr</span>)</span>;

    T* m_ptr;
};
</code></pre><p>这里声明了一些构造函数，重载了一些运算符，定义了指向真实对象的变量m_ptr。sp中重载了运算符“*”和“-&gt;”还有get()函数，因此我们可以像用普通指针那样利用sp操作原始对象。首先分析仪下sp的构造函数、析构函数、重载赋值运算符。</p>
<pre><code>template&lt;typename T&gt;
sp&lt;T&gt;::sp(T* other)
    : m_ptr(other) {
    <span class="keyword">if</span> (other)
        other-&gt;incStrong(<span class="keyword">this</span>);
}
</code></pre><p>T必然是继承于RefBase或者LightRefBase的，以真实对象的指针为参数构造sp对象，如果指针不是NULL，调用对象的incStrong函数增加引用计数。</p>
<pre><code>template&lt;typename T&gt;
sp&lt;T&gt;::sp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other)
    : m_ptr(other.m_ptr) {
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;incStrong(<span class="keyword">this</span>);
}
</code></pre><p>复制构造函数，如果m_ptr不是NULL，调用对象的incStrong函数增加引用计数。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
sp&lt;T&gt;::sp(U* other)
    : m_ptr(other) {
    <span class="keyword">if</span> (other)
        ((T*) other)-&gt;incStrong(<span class="keyword">this</span>);
}
</code></pre><p>和第一个构造函数类似，U和T具有继承关系。比如定义了sp<t>对象，new出的对象是U类型的，U是T的子类（只要强制转换能成功），可以利用U类型对象创建sp<t>对象。</t></t></p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
sp&lt;T&gt;::sp(<span class="keyword">const</span> sp&lt;U&gt;&amp; other)
    : m_ptr(other.m_ptr) {
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;incStrong(<span class="keyword">this</span>);
}
</code></pre><p>和第二个构造函数类似，U和T具有继承关系。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
sp&lt;T&gt;::~sp() {
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;decStrong(<span class="keyword">this</span>);
}
</code></pre><p>sp对象析构的时候，如果m_ptr不是NULL，调用对象的decStrong函数减少引用计数。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
sp&lt;T&gt;&amp; sp&lt;T&gt;::<span class="keyword">operator</span> =(<span class="keyword">const</span> sp&lt;T&gt;&amp; other) {
    <span class="function">T* <span class="title">otherPtr</span><span class="params">(other.m_ptr)</span></span>;
    <span class="keyword">if</span> (otherPtr)
        otherPtr-&gt;incStrong(<span class="keyword">this</span>);
    <span class="keyword">if</span> (m_ptr)
    m_ptr-&gt;decStrong(<span class="keyword">this</span>);
    m_ptr = otherPtr;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>重载赋值运算符，增加other所指向对象的引用计数，如果这个sp对象之前指向了其他对象，还需要减少那个对象的引用计数。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
sp&lt;T&gt;&amp; sp&lt;T&gt;::<span class="keyword">operator</span> =(T* other) {
    <span class="keyword">if</span> (other)
        other-&gt;incStrong(<span class="keyword">this</span>);
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;decStrong(<span class="keyword">this</span>);
    m_ptr = other;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>重载赋值运算符，增加other对象的引用计数，如果这个sp对象之前指向了其他对象，还需要减少那个对象的引用计数。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
sp&lt;T&gt;&amp; sp&lt;T&gt;::<span class="keyword">operator</span> =(<span class="keyword">const</span> sp&lt;U&gt;&amp; other) {
    <span class="function">T* <span class="title">otherPtr</span><span class="params">(other.m_ptr)</span></span>;
    <span class="keyword">if</span> (otherPtr)
        otherPtr-&gt;incStrong(<span class="keyword">this</span>);
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;decStrong(<span class="keyword">this</span>);
    m_ptr = otherPtr;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>同上，U和T具有继承关系。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
sp&lt;T&gt;&amp; sp&lt;T&gt;::<span class="keyword">operator</span> =(U* other) {
    <span class="keyword">if</span> (other)
        ((T*) other)-&gt;incStrong(<span class="keyword">this</span>);
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;decStrong(<span class="keyword">this</span>);
    m_ptr = other;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>同上，U和T具有继承关系。</p>
<p>下面着重分析incStrong和decStrong两个函数，因为LightRefBase中这两个函数的实现十分简单，这里就不赘述了，只分析RefBase的incStrong和decStrong<br>incStrong：</p>
<pre><code>void RefBase::incStrong(<span class="keyword">const</span> void* id) <span class="keyword">const</span>
{
    weakref_impl* <span class="keyword">const</span> refs = mRefs;
    refs-&gt;incWeak(id);
    <span class="keyword">const</span> int32_t c = android_atomic_inc(&amp;refs-&gt;mStrong);
    <span class="keyword">if</span> (c != INITIAL_STRONG_VALUE)  {
        <span class="keyword">return</span>;
    }
    android_atomic_add(-INITIAL_STRONG_VALUE, &amp;refs-&gt;mStrong);
    refs-&gt;mBase-&gt;onFirstRef();
}
</code></pre><p>RefBase中和引用计数相关的变量是mRefs，首先调用weakref_type的incWeak函数</p>
<pre><code><span class="keyword">void</span> RefBase::weakref_type::incWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)
{
    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);
    <span class="keyword">const</span> <span class="keyword">int32_t</span> c __unused = android_atomic_inc(&amp;impl-&gt;mWeak);
}
</code></pre><p>这个函数所做的是增加mRefs的mWeak变量值。</p>
<p>然后调用android_atomic_inc(&amp;refs-&gt;mStrong)增加mRefs的mStrong变量值。c返回增加之前的值。<br>如果c不是INITIAL_STRONG_VALUE，直接返回。如果c是INITIAL_STRONG_VALUE，说明这个对象的强引用计数是第一次增加，mStrong的初始值是INITIAL_STRONG_VALUE，通过调用<br>android_atomic_add(-INITIAL_STRONG_VALUE, &amp;refs-&gt;mStrong);<br>让mStrong的值变为1。同时如果有需要的话还可以调用重写的onFirstRef()回调函数。</p>
<p>decStrong：</p>
<pre><code><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span>
{
    weakref_impl* <span class="keyword">const</span> refs = mRefs;
    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);
    <span class="keyword">if</span> (c == <span class="number">1</span>) {
        refs-&gt;mBase-&gt;onLastStrongRef(id);
        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {
            <span class="keyword">delete</span> <span class="keyword">this</span>;
        }
    }
    refs-&gt;decWeak(id);
}
</code></pre><p>首先减少mRefs的mStrong变量值，如果返回值c等于1，说明现在mStrong是0，对象内存有被释放掉的可能。<br>调用完onLastStrongRef()回调函数后，判断mFlags的取值，如果是OBJECT_LIFETIME_STRONG，则说明对象生命周期受强引用计数控制，强引用计数为0，则原始对象就要被delete掉了。<br>不管原始对象有没有被delete掉，还是会调用decWeak见少弱引用计数的。</p>
<pre><code><span class="keyword">void</span> RefBase::weakref_type::decWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)
{
    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);
    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;impl-&gt;mWeak);
    <span class="keyword">if</span> (c != <span class="number">1</span>) <span class="keyword">return</span>;
    <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) {
        <span class="comment">// This is the regular lifetime case. The object is destroyed</span>
        <span class="comment">// when the last strong reference goes away. Since weakref_impl</span>
        <span class="comment">// outlive the object, it is not destroyed in the dtor, and</span>
        <span class="comment">// we'll have to do it here.</span>
        <span class="keyword">if</span> (impl-&gt;mStrong == INITIAL_STRONG_VALUE) {
            <span class="comment">// Special case: we never had a strong reference, so we need to</span>
            <span class="comment">// destroy the object now.</span>
            <span class="keyword">delete</span> impl-&gt;mBase;
        } <span class="keyword">else</span> {
            <span class="comment">// ALOGV("Freeing refs %p of old RefBase %p\n", this, impl-&gt;mBase);</span>
            <span class="keyword">delete</span> impl;
        }
    } <span class="keyword">else</span> {
        <span class="comment">// less common case: lifetime is OBJECT_LIFETIME_{WEAK|FOREVER}</span>
        impl-&gt;mBase-&gt;onLastWeakRef(id);
        <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) {
            <span class="comment">// this is the OBJECT_LIFETIME_WEAK case. The last weak-reference</span>
            <span class="comment">// is gone, we can destroy the object.</span>
            <span class="keyword">delete</span> impl-&gt;mBase;
        }
    }
}
</code></pre><p>decWeak函数首先减少mWeak的值，如果mWeak不是0，直接退出。如果mWeak是0，就要根据策略来决定是否要释放对象内存了。</p>
<p>如果mFlags是OBJECT_LIFETIME_STRONG，分两种情况：<br>1.mStrong从未增加仍然是初始值，说明没有任何sp指向过这个对象，只有弱指针指向过这个对象，因此，直接删除原始对象。在Refbase的析构函数中，delete变量mRefs。<br>2.mStrong不是初始值，说明此时mStrong一定是0，因为sp构造时会同时增加强指针计数和弱指针计数，析构时会减少强指针计数和弱指针计数，wp构造时只会增加弱引用技术，析构时只会减少弱指针计数。所以这里mWeak是0，mStrong一定是0。前面在decStrong中原始对象已经被delete掉了，这里只需要delete掉在RefBase中new出来的对象mRefs即可。Refbase的析构函数中也会尝试delete成员变量mRefs，但需要判断条件mRefs-&gt;mWeak为0，这种情形下，mWeak是在delete原始对象后减为0的，条件不成里。</p>
<pre><code>RefBase::~RefBase()
{
    <span class="keyword">if</span> (mRefs-&gt;mStrong == INITIAL_STRONG_VALUE) {
        <span class="comment">// we never acquired a strong (and/or weak) reference on this object.</span>
        <span class="keyword">delete</span> mRefs;
    } <span class="keyword">else</span> {
        <span class="comment">// life-time of this object is extended to WEAK or FOREVER, in</span>
        <span class="comment">// which case weakref_impl doesn't out-live the object and we</span>
        <span class="comment">// can free it now.</span>
        <span class="keyword">if</span> ((mRefs-&gt;mFlags &amp; OBJECT_LIFETIME_MASK) != OBJECT_LIFETIME_STRONG) {
            <span class="comment">// It's possible that the weak count is not 0 if the object</span>
            <span class="comment">// re-acquired a weak reference in its destructor</span>
            <span class="keyword">if</span> (mRefs-&gt;mWeak == <span class="number">0</span>) {
                <span class="keyword">delete</span> mRefs;
            }
        }
    }
}

}
</code></pre><p>如果mFlags是OBJECT_LIFETIME_WEAK，那么decStrong中就不会因为mStrong为0就把原始对象释放掉，必须要求mWeak为0才会delete对象，mRefs的变量mBase指向原始对象。此时在Refbase的析构函数，mRefs-&gt;mWeak为0，因此会delete变量mRefs。</p>
<p>通古上面的分析，这里总结下mFlags取值的涵义：<br>OBJECT_LIFETIME_STRONG：强引用计数控制真实对象的生命周期，弱引用计数控制weakref_impl类型对象mRefs的生命周期。强引用计数为0后，实际对象被delete。弱引用计数为0后，mRefs对象被delete。<br>OBJECT_LIFETIME_WEAK：强引用计数为0，弱引用计数不为0时，实际对象不会被delete。当弱引用计数减为0时，实际对象和mRefs对象会同时被delete。<br>mFlags的默认值是0，即是OBJECT_LIFETIME_STRONG。如果想要改变策略，需要调用RefBase的protected的函数extendObjectLifetime(int32_t mode)设置mFlags的值。</p>
<p><strong>五. wp弱指针</strong></p>
<p>下面开始分析弱指针wp，他的定义在RefBase.h文件中。</p>
<pre><code>template &lt;typename T&gt;
<span class="class"><span class="keyword">class</span> <span class="title">wp</span>
</span>{
  public:
    <span class="literal">typedef</span> typename RefBase::weakref_type weakref_type;

    inline wp() : m_ptr(<span class="number">0</span>) { }

    wp(T* other);
    wp(<span class="keyword">const</span> wp&amp; other);
    wp(<span class="keyword">const</span> sp&amp; other);
    template wp(U* other);
    template wp(<span class="keyword">const</span> sp&lt;u&gt;&amp; other);
    template wp(<span class="keyword">const</span> wp&lt;u&gt;&amp; other);

    ~wp();

    <span class="comment">// Assignment</span>

    wp&amp; <span class="literal">operator</span> = (T* other);
    wp&amp; <span class="literal">operator</span> = (<span class="keyword">const</span> wp&amp; other);
    wp&amp; <span class="literal">operator</span> = (<span class="keyword">const</span> sp&amp; other);

    template wp&amp; <span class="literal">operator</span> = (U* other);
    template wp&amp; <span class="literal">operator</span> = (<span class="keyword">const</span> wp&lt;u&gt;&amp; other);
    template wp&amp; <span class="literal">operator</span> = (<span class="keyword">const</span> sp&lt;u&gt;&amp; other);

    <span class="keyword">void</span> set_object_and_refs(T* other, weakref_type* refs);

    <span class="comment">// promotion to sp</span>

    sp promote() <span class="keyword">const</span>;

    <span class="comment">// Reset</span>

    <span class="keyword">void</span> clear();

    <span class="comment">// Accessors</span>

    inline  weakref_type* get_refs() <span class="keyword">const</span> { <span class="keyword">return</span> m_refs; }

    inline  T* unsafe_get() <span class="keyword">const</span> { <span class="keyword">return</span> m_ptr; }

    <span class="comment">// Operators</span>

    COMPARE_WEAK(==)
    COMPARE_WEAK(!=)
    COMPARE_WEAK(&gt;)
    COMPARE_WEAK(&lt;)
    COMPARE_WEAK(&lt;=)     COMPARE_WEAK(&gt;=)

    inline <span class="built_in">bool</span> <span class="literal">operator</span> == (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> (m_ptr == o.m_ptr) &amp;&amp; (m_refs == o.m_refs);
    }
    template
    inline <span class="built_in">bool</span> <span class="literal">operator</span> == (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> m_ptr == o.m_ptr;
    }

    inline <span class="built_in">bool</span> <span class="literal">operator</span> &gt; (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> (m_ptr == o.m_ptr) ? (m_refs &gt; o.m_refs) : (m_ptr &gt; o.m_ptr);
    }
    template
    inline <span class="built_in">bool</span> <span class="literal">operator</span> &gt; (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> (m_ptr == o.m_ptr) ? (m_refs &gt; o.m_refs) : (m_ptr &gt; o.m_ptr);
    }

    inline <span class="built_in">bool</span> <span class="literal">operator</span> &lt; (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> (m_ptr == o.m_ptr) ? (m_refs &lt; o.m_refs) : (m_ptr &lt; o.m_ptr);
    }
    template
    inline <span class="built_in">bool</span> <span class="literal">operator</span> &lt; (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> (m_ptr == o.m_ptr) ? (m_refs &lt; o.m_refs) : (m_ptr &lt; o.m_ptr);
    }
                         inline <span class="built_in">bool</span> <span class="literal">operator</span> != (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> m_refs != o.m_refs; }
    template inline <span class="built_in">bool</span> <span class="literal">operator</span> != (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> !<span class="literal">operator</span> == (o); }
                         inline <span class="built_in">bool</span> <span class="literal">operator</span> &lt;= (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> !<span class="literal">operator</span> &gt; (o); }
    template inline <span class="built_in">bool</span> <span class="literal">operator</span> &lt;= (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> !<span class="literal">operator</span> &gt; (o); }
                         inline <span class="built_in">bool</span> <span class="literal">operator</span> &gt;= (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> !<span class="literal">operator</span> &lt; (o); }
    template inline <span class="built_in">bool</span> <span class="literal">operator</span> &gt;= (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> !<span class="literal">operator</span> &lt; (o); }

  private:
    template friend <span class="class"><span class="keyword">class</span> <span class="title">sp</span>;
    <span class="title">template</span> <span class="title">friend</span> <span class="title">class</span> <span class="title">wp</span>;

    <span class="title">T</span>*              <span class="title">m_ptr</span>;
    <span class="title">weakref_type</span>*   <span class="title">m_refs</span>;
};&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;</span>
</code></pre><p>和sp一样，这里声明了一些构造函数，重载了一些运算符，定义了指向真实对象的变量m_ptr。但是wp中并没有重载“*”和“-&gt;”运算符，能获取原始对象的也只有一个unsafe_get()函数，因此我们是不能利用wp直接操作对象的。此外还有类型是weakref_type成员变量m_refs。下面来分析几个典型的wp的构造函数和析构函数</p>
<pre><code>template&lt;typename T&gt;

wp&lt;T&gt;::wp(T* other)
: m_ptr(other)
{
    <span class="keyword">if</span> (other) m_refs = other-&gt;createWeak(<span class="keyword">this</span>);
}
</code></pre><p>用原始对象的指针为参数构造wp，如果other不为NULL，则调用原始对象的createWeak，返回值赋予m_refs。看来createWeak函数比较关键。</p>
<pre><code>template&lt;typename T&gt;
wp&lt;T&gt;::wp(<span class="keyword">const</span> wp&lt;T&gt;&amp; other)
: m_ptr(other.m_ptr), m_refs(other.m_refs)
{
    <span class="keyword">if</span> (m_ptr) m_refs-&gt;incWeak(<span class="keyword">this</span>);
}
</code></pre><p>复制构造函数，调用m_ref的incWeak增加弱引用计数。</p>
<pre><code>template&lt;typename T&gt;
wp&lt;T&gt;::wp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other)
: m_ptr(other.m_ptr)
{
    <span class="keyword">if</span> (m_ptr) {
        m_refs = m_ptr-&gt;createWeak(<span class="keyword">this</span>);
    }
}
</code></pre><p>用强指针对象为参数构造wp，强指针指向的真实对象指针赋予弱指针的m_ptr，同时调用createWeak。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
wp&lt;T&gt;::~wp()
{
    <span class="keyword">if</span> (m_ptr) m_refs-&gt;decWeak(<span class="keyword">this</span>);
}
</code></pre><p>wp析构时调用decWeak减少弱引用计数</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
wp&lt;T&gt;&amp; wp&lt;T&gt;::<span class="keyword">operator</span> = (T* other)
{
    weakref_type* newRefs = other ? other-&gt;createWeak(<span class="keyword">this</span>) : <span class="number">0</span>;
    <span class="keyword">if</span> (m_ptr) m_refs-&gt;decWeak(<span class="keyword">this</span>);
    m_ptr = other;
    m_refs = newRefs;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>重载赋值运算符，新指向的对象调用createWeak，原来指向的对象减少弱引用计数，更新相关指针指向的对象。</p>
<p>看来wp中比较关键的几个方法是createWeak、incWeak、decWeak。incWeak、decWeak前面已经分析过了，下面将分别分析createWeak。</p>
<pre><code>RefBase::weakref_type* RefBase::createWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span>
{
    mRefs-&gt;incWeak(id);
    <span class="keyword">return</span> mRefs;
}
</code></pre><p>createWeak是RefBase中的方法，他会调用incWeak增加对象的弱引用计数。同时将对象的mRefs返回，并赋给wp中定义的成员变量m_refs。于是，wp对象中有了一个原始对象mRefs指针变量的副本。改变弱引用计数的相关函数incWeak、decWeak是定义在weakref_type中的，因此wp需要weakref_type类型的变量去调用这些函数。改变强引用计数的相关函数incStrong、decStrong是定义在RefBase中的，因此sp不需要weakref_type类型的变量。</p>
<p>前面已经说过了，wp没法直接用来操作原始对象，虽然他可能指向了一个确实存在的原始对象，要想访问wp指向的这个原始对象，必须用promote函数将wp提升为sp，然后通过sp来访问。于是关键就在于这个promote函数，下面来分析这个函数。</p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;

sp&lt;T&gt; wp&lt;T&gt;::promote() <span class="keyword">const</span>
{
    sp&lt;T&gt; <span class="literal">result</span>;
    <span class="keyword">if</span> (m_ptr &amp;&amp; m_refs-&gt;attemptIncStrong(&amp;<span class="literal">result</span>)) {
        <span class="literal">result</span>.set_pointer(m_ptr);
    }
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>result将调用sp的默认构造函数，他的成员变量m_pt会初始化为NULL，因此如果promote不成功，将返回一个指向为NULL的sp。</p>
<p>m_ptr是NULL的情况只有用户自己传给了wp一个NULL指针构造wp，否则m_ptr不为NULL，但是他可能指向一个已经被delete掉的对象，所以要调用后面的attemptIncStrong函数继续进行判断。</p>
<p>什么情况下会出现wp指向一个已经被delete掉的对象的情况呢，看下面的代码。</p>
<pre><code>{
    <span class="keyword">A</span>* a = new <span class="keyword">A</span>()<span class="comment">;</span>
    wp&lt;<span class="keyword">A</span>&gt; m_wp(a)<span class="comment">;</span>
    {
        sp&lt;<span class="keyword">A</span>&gt; m_sp = a<span class="comment">;</span>
    }
    sp&lt;<span class="keyword">A</span>&gt;m_promote_wp = m_wp.promote()<span class="comment">;</span>
}
</code></pre><p>m_wp构造时会增加弱引用计数，此时弱引用计数为1。sp构造时会增加强引用计数和弱引用计数，此时强引用计数为1，弱引用计数为2。<br>m_sp从大括号中出来时会调用sp的析构函数，同时减少强引用计数和弱引用计数，此时强引用计数为0，弱引用计数为1。<br>根据前面对decStrong的分析，如果对象受强引用计数控制，即mFlags为OBJECT_LIFETIME_STRONG，则会delete掉真实对象。这时调用promote，就会失败得到一个指向NULL的sp。<br>下面着重分析attemptIncStrong是如何运作的。</p>
<pre><code><span class="keyword">bool</span> RefBase::weakref_type::attemptIncStrong(<span class="keyword">const</span> void* id)
{
    incWeak(id);

    weakref_impl* <span class="keyword">const</span> <span class="keyword">impl</span> = static_cast&lt;weakref_impl*&gt;(this);
    int32_t curCount = <span class="keyword">impl</span>-&gt;mStrong;

    <span class="keyword">while</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount != INITIAL_STRONG_VALUE) {
        <span class="comment">// we're in the easy/common case of promoting a weak-reference</span>
        <span class="comment">// from an existing strong reference.</span>
        <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount+<span class="number">1</span>, &amp;<span class="keyword">impl</span>-&gt;mStrong) == <span class="number">0</span>) {
            <span class="keyword">break</span>;
        }
        <span class="comment">// the strong count has changed on us, we need to re-assert our</span>
        <span class="comment">// situation.</span>
        curCount = <span class="keyword">impl</span>-&gt;mStrong;
    }

    <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span> || curCount == INITIAL_STRONG_VALUE) {         
        <span class="comment">// we're now in the harder case of either:         </span>
        <span class="comment">// - there never was a strong reference on us         </span>
        <span class="comment">// - or, all strong references have been released         </span>
        <span class="keyword">if</span> ((<span class="keyword">impl</span>-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) {
            <span class="comment">// this object has a "normal" life-time, i.e.: it gets destroyed</span>
            <span class="comment">// when the last strong reference goes away</span>
            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) {                 
                <span class="comment">// the last strong-reference got released, the object cannot                 </span>
                <span class="comment">// be revived.                 </span>
                decWeak(id);                 
                <span class="keyword">return</span> <span class="keyword">false</span>;            
            }             
            <span class="comment">// here, curCount == INITIAL_STRONG_VALUE, which means             </span>
            <span class="comment">// there never was a strong-reference, so we can try to             </span>
            <span class="comment">// promote this object; we need to do that atomically.             </span>
            <span class="keyword">while</span> (curCount &gt; <span class="number">0</span>) {
                <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount + <span class="number">1</span>,
                        &amp;<span class="keyword">impl</span>-&gt;mStrong) == <span class="number">0</span>) {
                    <span class="keyword">break</span>;
                }
                <span class="comment">// the strong count has changed on us, we need to re-assert our</span>
                <span class="comment">// situation (e.g.: another thread has inc/decStrong'ed us)</span>
                curCount = <span class="keyword">impl</span>-&gt;mStrong;
            }

            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) {                 
                <span class="comment">// promote() failed, some other thread destroyed us in the                 </span>
                <span class="comment">// meantime (i.e.: strong count reached zero).                 </span>
                decWeak(id);                 
                <span class="keyword">return</span> <span class="keyword">false</span>;             
            }         
        } <span class="keyword">else</span> {     
            <span class="comment">// this object has an "extended" life-time, i.e.: it can be             </span>
            <span class="comment">// revived from a weak-reference only.             </span>
            <span class="comment">// Ask the object's implementation if it agrees to be revived             </span>
            <span class="keyword">if</span> (!<span class="keyword">impl</span>-&gt;mBase-&gt;onIncStrongAttempted(FIRST_INC_STRONG, id)) {
                <span class="comment">// it didn't so give-up.</span>
                decWeak(id);
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
            <span class="comment">// grab a strong-reference, which is always safe due to the</span>
            <span class="comment">// extended life-time.</span>
            curCount = android_atomic_inc(&amp;<span class="keyword">impl</span>-&gt;mStrong);
        }

        <span class="comment">// If the strong reference count has already been incremented by</span>
        <span class="comment">// someone else, the implementor of onIncStrongAttempted() is holding</span>
        <span class="comment">// an unneeded reference.  So call onLastStrongRef() here to remove it.</span>
        <span class="comment">// (No, this is not pretty.)  Note that we MUST NOT do this if we</span>
        <span class="comment">// are in fact acquiring the first reference.</span>
        <span class="keyword">if</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount &lt; INITIAL_STRONG_VALUE) {             
            <span class="keyword">impl</span>-&gt;mBase-&gt;onLastStrongRef(id);
        }
    }
    <span class="comment">// now we need to fix-up the count if it was INITIAL_STRONG_VALUE</span>
    <span class="comment">// this must be done safely, i.e.: handle the case where several threads</span>
    <span class="comment">// were here in attemptIncStrong().</span>
    curCount = <span class="keyword">impl</span>-&gt;mStrong;
    <span class="keyword">while</span> (curCount &gt;= INITIAL_STRONG_VALUE) {
        ALOG_ASSERT(curCount &gt; INITIAL_STRONG_VALUE,
                <span class="string">"attemptIncStrong in %p underflowed to INITIAL_STRONG_VALUE"</span>,
                this);
        <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount-INITIAL_STRONG_VALUE,
                &amp;<span class="keyword">impl</span>-&gt;mStrong) == <span class="number">0</span>) {
            <span class="keyword">break</span>;
        }
        <span class="comment">// the strong-count changed on us, we need to re-assert the situation,</span>
        <span class="comment">// for e.g.: it's possible the fix-up happened in another thread.</span>
        curCount = <span class="keyword">impl</span>-&gt;mStrong;
    }

    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p>首先调用incWeak来增加mWeak计数，因为这里需要获取sp指针，在sp的构造函数我们知道，会同时增加mWeak和mStrong值。然后根据mStong值分两种情况讨论：</p>
<p>1.目标对象正在被其它强指针引用，即它的强引用计数大于0，并且不等于INITIAL_STRONG_VALUE，这时候说明目标对象一定存在，因此，是可以将这个弱指针提升为强指针的，在这种情况下，只要简单地增加目标对象的强引用计数值就行了。<br>2.目标对象没有被任何强指针引用，即它的强引用计数小于等于0，或者等于INITIAL_STRONG_VALUE，这时候目标对象可能还存在，也可能不存了，需要结合Flag去判断。又分为以下几种情况：</p>
<ul>
<li>Flag = OBJECT_LIFETIME_STRONG，并且curCount等于0。说明之前的sp对象已经释放，由前面的知识我们知道，在释放sp对象的同时也会释放原始对象，所以这里调用decWeak来释放前面增加的一次mWeak值并返回false。</li>
</ul>
<ul>
<li>Flag = OBJECT_LIFETIME_STRONG，并且curCount = INITIAL_STRONG_VALUE，说明前面没有sp引用，原始对象是一定存在的，这时我们可以增加mStrong值。</li>
</ul>
<ul>
<li>Flag = OBJECT_LIFETIME_WEAK，这时候由于目标对象正在被弱指针引用，因此，弱引用计数一定不为0，目标对象一定存在，需要进一步调用目标对象的onIncStrongAttempted来看看是否允许这种情况发生，目标对象的设计者可能本身就不希望这个对象被强指针引用，只能通过弱指针来引用它，因此，这里它就可以重载其父类的onIncStrongAttempted函数，然后返回false，这样就可以阻止弱指针都被提升为强指针。在RefBase类中，其成员函数onIncStrongAttempted默认是返回true的。于是增加mStrong值。</li>
</ul>
<p>当上面任何一种情况增加了mStrong值以后，mSrong的值可能大于INITIAL_STRONG_VALUE，也就是原来mSrong是从初始值INITIAL_STRONG_VALUE加上去的。我们需要去修正mStrong，就是通过减去INITIAL_STRONG_VALUE计算。<br>当attemptIncStrong返回true时，promote方法就会调用sp的set_pointer方法去设置StrongPointer中的实际A对象的指针。接下来就可以通过sp调用相关的方法了。</p>
<p>参考文章：<br><a href="http://blog.csdn.net/luoshengyang/article/details/6786239" target="_blank" rel="external">http://blog.csdn.net/luoshengyang/article/details/6786239</a><br><a href="http://blog.csdn.net/lilian0118/article/details/23662383" target="_blank" rel="external">http://blog.csdn.net/lilian0118/article/details/23662383</a></p>

      
      
    </div>
    
  </div>
  
    
<div class="copyright">
  <p><span>本文标题:</span><a href="/2015/07/17/2015-07-17-androide699bae883bde68c87e99288sp-wpe58e9fe79086e58886e69e90/">android智能指针(sp wp)原理分析</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 John Doe 的个人博客">John Doe</a></p>
  <p><span>发布时间:</span>2015年7月17日 - 05时07分</p>
  <p><span>最后更新:</span>2015年10月30日 - 11时10分</p>
  <p>
    <span>原始链接:</span><a href="/2015/07/17/2015-07-17-androide699bae883bde68c87e99288sp-wpe58e9fe79086e58886e69e90/" title="android智能指针(sp wp)原理分析">http://yoursite.com/2015/07/17/2015-07-17-androide699bae883bde68c87e99288sp-wpe58e9fe79086e58886e69e90/</a>
    <span class="btn" data-clipboard-text="原文: http://yoursite.com/2015/07/17/2015-07-17-androide699bae883bde68c87e99288sp-wpe58e9fe79086e58886e69e90/　　作者: John Doe" title="点击复制文章链接">
        <i class="fa fa-clipboard"></i>
    </span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。</p>
  <script src="/js/clipboard.min.js"></script>
  <script> var clipboard = new Clipboard('.btn'); </script>
</div>
<style type="text/css">
  .copyright p .btn {
    margin-left: 1em;
  }
  .copyright:hover p .btn::after {
    content: "复制"
  }
  .copyright p .btn:hover {
      color: gray;
      cursor: pointer;
    };
</style>



<nav id="article-nav">
  
    <div id="article-nav-newer" class="article-nav-title">
      <a href="/2015/07/21/2015-07-21-androide4b8ad-e5bcb1e68c87e99288-wpe79a84e4bd9ce794a8/">
        android中 弱指针 (wp)的作用
      </a>
    </div>
  
  
    <div id="article-nav-older" class="article-nav-title">
      <a href="/2015/05/09/2015-05-09-e8a7a3e586b3-android-studio-e697a0e6b395e69bb4e696b0e79a84e997aee9a298/">
        解决 Android Studio Android SDK 无法更新的问题
      </a>
    </div>
  
</nav>

  
</article>

<!-- 默认显示文章目录，在文章---前输入toc: false关闭目录 -->
<!-- Show TOC and tocButton in default, Hide TOC via putting "toc: false" before "---" at [post].md -->
<div id="toc" class="toc-article">
<strong class="toc-title">文章目录</strong>

</div>
<style type="text/css">
  .left-col .switch-btn {
    display: none;
  }
  .left-col .switch-area {
    display: none;
  }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script type="text/javascript">
  var toc_button= document.getElementById("tocButton");
  var toc_div= document.getElementById("toc");
  /* Show or hide toc when click on tocButton.
  通过点击设置的按钮显示或者隐藏文章目录.*/
  toc_button.onclick=function(){
  if(toc_div.style.display=="none"){
  toc_div.style.display="block";
  toc_button.value="隐藏目录";
  document.getElementById("switch-btn").style.display="none";
  document.getElementById("switch-area").style.display="none";
  }
  else{
  toc_div.style.display="none";
  toc_button.value="显示目录";
  document.getElementById("switch-btn").style.display="block";
  document.getElementById("switch-area").style.display="block";
  }
  }
</script>


<div class="share">
	<div class="bdsharebuttonbox">
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
	<a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
	<a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
	</div>
	<script>
	window._bd_share_config={
		"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	</script>
</div>







    <style type="text/css">
    #scroll {
      display: none;
    }
    </style>
    <div class="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#ds-thread" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
    </div>


  
  
    
    <div  class="post-nav-button">
    <a href="/2015/07/21/2015-07-21-androide4b8ad-e5bcb1e68c87e99288-wpe79a84e4bd9ce794a8/" title="上一篇: android中 弱指针 (wp)的作用">
    <i class="fa fa-angle-left"></i>
    </a>
    <a href="/2015/05/09/2015-05-09-e8a7a3e586b3-android-studio-e697a0e6b395e69bb4e696b0e79a84e997aee9a298/" title="下一篇: 解决 Android Studio Android SDK 无法更新的问题">
    <i class="fa fa-angle-right"></i>
    </a>
    </div>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2015 John Doe
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
        </div>
    </div>
    <div class="visit">
      <span id="busuanzi_container_site_pv" style='display:none'>
        <span id="site-visit" >本站到访数: 
        <span id="busuanzi_value_site_uv"></span>
        </span>
      </span>
      <span id="busuanzi_container_page_pv" style='display:none'>
        <span id="page-visit">, 本页阅读量: 
        <span id="busuanzi_value_page_pv"></span>
        </span>
      </span>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

<script type="text/javascript">
  var backgroundList = ["url(/background/bg-1.jpg)", "url(/background/bg-2.jpg)","url(/background/bg-3.jpg)","url(/background/bg-4.jpg)","url(/background/bg-5.jpg)"];
  var background = Math.floor(Math.random() * backgroundList.length);
  $("body").css({"background": backgroundList[background], "background-attachment": "fixed", "background-size": "cover"});
</script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
<a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
<a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>