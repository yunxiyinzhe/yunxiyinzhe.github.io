<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Dylan Gao</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Dylan Gao">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Dylan Gao">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dylan Gao">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Dylan Gao" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Dylan Gao</a></h1>
		</hgroup>

		
				


		
			<div id="switch-btn" class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div id="switch-area" class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags">标签云</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="mailto:123@123.com" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="/#" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="/tags/Java学习/" style="font-size: 20px;">Java学习</a> <a href="/tags/Java转载/" style="font-size: 13.33px;">Java转载</a> <a href="/tags/PS4/" style="font-size: 10px;">PS4</a> <a href="/tags/PSVITA/" style="font-size: 10px;">PSVITA</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/android/" style="font-size: 16.67px;">android</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">专注于前端</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Dylan Gao</a></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<a href="/" class="profilepic">
				<img lazy-src="/img/avatar.png" class="js-avatar">
			</a>
			<hgroup>
			  <h1 class="header-author"><a href="/" title="回到主页">Dylan Gao</a></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags">标签云</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
						<ul class="social">
							
								<li id="Email"><a class="Email" target="_blank" href="mailto:123@123.com" title="Email"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="/#" title="GitHub"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-2015-09-18-e5889de5ada6-python-e99984e4b88ae587a0e4b8aae7bb83e4b9a0e5b08fe7a88be5ba8f" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/18/2015-09-18-e5889de5ada6-python-e99984e4b88ae587a0e4b8aae7bb83e4b9a0e5b08fe7a88be5ba8f/" class="article-date">
  	<time datetime="2015-09-17T22:27:39.000Z" itemprop="datePublished">2015-09-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/18/2015-09-18-e5889de5ada6-python-e99984e4b88ae587a0e4b8aae7bb83e4b9a0e5b08fe7a88be5ba8f/">初学 Python 附上几个练习小程序</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前的学习和工作中，只用到C/C++和Java两种编程语言。一直听说Python易学，易用，又强大，也曾经尝试学习，不过后来只是开了个头就不了了之了。这次决心要学习Python，不求有多精深，只要入门就行，剩下的慢慢来。</p>
<p>为了追求速成，不求深入，就直接开始看廖雪峰的Python教程了，浅显易懂，适合入门</p>
<p><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000</a></p>
<p>利用闲暇时间，花了大约一周多算是走马观花地看完了。毕竟有C++和Java的经验，很多特性和用法与那两种高级语言都是很相似的。但是Python作为一种动态语言，还是有不少独特的地方，切片操作，函数式编程，动态添加属性，元类，丰富的库函数等等。所以，Python绝对是一门值得学习的语言。下面是学习Python中用来练习的几个小程序，记录一下。由于是初学，代码风格恐怕很难摆脱C++和Java的痕迹，不够Pythonic。</p>
<p>1.汉诺塔</p>
<pre><code>def <span class="function"><span class="title">hannoi</span><span class="params">(n, a, b, c)</span></span>:
    <span class="function"><span class="title">if</span><span class="params">(n == <span class="number">1</span>)</span></span>:
        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'move %d from %s to %s'</span> % (n, a, c)</span></span>)
    <span class="keyword">else</span>:
        <span class="function"><span class="title">hannoi</span><span class="params">(n - <span class="number">1</span>, a, c, b)</span></span>
        <span class="function"><span class="title">hannoi</span><span class="params">(<span class="number">1</span>, a, b, c)</span></span>
        <span class="function"><span class="title">hannoi</span><span class="params">(n - <span class="number">1</span>, b, a, c)</span></span>
<span class="function"><span class="title">hannoi</span><span class="params">(<span class="number">6</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span></span>
</code></pre><p>2.斐波那契数列</p>
<pre><code>def <span class="function"><span class="title">fibonacci</span><span class="params">(n)</span></span>:
    <span class="function"><span class="title">if</span><span class="params">(n &lt;= <span class="number">0</span>)</span></span>:
        <span class="function"><span class="title">print</span><span class="params">(<span class="string">'input error'</span>)</span></span>
        return <span class="number">0</span>
    <span class="function"><span class="title">elif</span><span class="params">(n == <span class="number">1</span> or n ==<span class="number">2</span>)</span></span>:
        return <span class="number">1</span>
    <span class="keyword">else</span>:
        return <span class="function"><span class="title">fibonacci</span><span class="params">(n-<span class="number">1</span>)</span></span> + <span class="function"><span class="title">fibonacci</span><span class="params">(n-<span class="number">2</span>)</span></span>
<span class="function"><span class="title">print</span><span class="params">(fibonacci(<span class="number">5</span>)</span></span>)
</code></pre><p>3.全排列</p>
<pre><code>def permutate(str):
    <span class="keyword">if</span>( <span class="keyword">not</span> str.strip()):
        <span class="keyword">return</span> ['']
    <span class="keyword">else</span>:
        first = str[<span class="number">0</span>]
        substr = permu(str[<span class="number">1</span>:])
        <span class="literal">result</span> = []
        <span class="keyword">for</span> tmp <span class="keyword">in</span> substr:
            n = <span class="number">0</span>
            <span class="keyword">while</span> n &lt;= len(tmp):
                tmpTolist = list(tmp)
                tmpTolist.insert(n, first)
                <span class="literal">result</span>.append(''.join(tmpTolist))
                n = n + <span class="number">1</span>
        <span class="keyword">return</span> <span class="literal">result</span>

print(permutate('abc'))
</code></pre><p>4.素数</p>
<pre><code>def primes(N):
    L = list(<span class="type">range</span>(<span class="number">2</span>, N))
    def not_divisible(n):
        <span class="keyword">return</span> lambda x: x % n &gt; <span class="number">0</span>

    <span class="literal">result</span> = []
    <span class="keyword">while</span> L != []:
        m = L[<span class="number">0</span>]
        <span class="literal">result</span>.append(L[<span class="number">0</span>])
        L = list(filter(not_divisible(m), L[<span class="number">1</span>:]))
    <span class="keyword">return</span> <span class="literal">result</span>

print(primes(<span class="number">100</span>))
</code></pre><p>5.回文数</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(n)</span>:</span>
    str_num = str(n)
    str_num_revert = str_num[::-<span class="number">1</span>]
    <span class="keyword">return</span> str_num == str_num_revert

print(list(filter(is_palindrome, range(<span class="number">1</span>, <span class="number">1000</span>))))
</code></pre><p>6.搜索文件</p>
<pre><code>def <span class="function"><span class="title">find_file_contains_str</span><span class="params">(folder, str)</span></span>:
    files = []
    def <span class="function"><span class="title">find_files</span><span class="params">(folder)</span></span>:
        <span class="keyword">if</span> not folder[-<span class="number">1</span>] == <span class="string">'/'</span>:
            folder = folder + <span class="string">'/'</span>
        <span class="keyword">for</span> x <span class="keyword">in</span> os.<span class="function"><span class="title">listdir</span><span class="params">(folder)</span></span>:
            <span class="keyword">if</span> os<span class="class">.path</span><span class="class">.isfile</span>(folder + x):
                files.<span class="function"><span class="title">append</span><span class="params">(folder + x)</span></span>
            <span class="keyword">else</span>:
                <span class="function"><span class="title">find_files</span><span class="params">(folder + x)</span></span>
        return files
    result = []
    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="function"><span class="title">find_files</span><span class="params">(folder)</span></span>:
        <span class="keyword">if</span> str <span class="keyword">in</span> x.<span class="function"><span class="title">split</span><span class="params">(<span class="string">'/'</span>)</span></span>[-<span class="number">1</span>]:
            result.<span class="function"><span class="title">append</span><span class="params">(x.split(<span class="string">'/'</span>)</span></span>[-<span class="number">1</span>])
    return result

<span class="function"><span class="title">print</span><span class="params">(find_file_contains_str(<span class="string">'/home/dylangao/'</span>, <span class="string">'txt'</span>)</span></span>)
</code></pre><p>7.kmp字符串匹配算法</p>
<pre><code>def <span class="function"><span class="title">partial_match_table</span><span class="params">(str)</span></span>:
    result = []
    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(len(str)</span></span> + <span class="number">1</span>):
        tmp_str = str[:n]
        f_list = []
        b_list = []
        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(len(tmp_str)</span></span>-<span class="number">1</span>):
            f_list.<span class="function"><span class="title">append</span><span class="params">(tmp_str[:(m+<span class="number">1</span>)</span></span>])
            b_list.<span class="function"><span class="title">append</span><span class="params">(tmp_str[(m+<span class="number">1</span>)</span></span>:(<span class="function"><span class="title">len</span><span class="params">(tmp_str)</span></span>)])

        max_len = <span class="number">0</span>
        <span class="keyword">for</span> fl <span class="keyword">in</span> f_list:
            <span class="keyword">for</span> bl <span class="keyword">in</span> b_list:
                <span class="keyword">if</span> fl == bl and <span class="function"><span class="title">len</span><span class="params">(bl)</span></span> &gt; max_len:
                        max_len = <span class="function"><span class="title">len</span><span class="params">(bl)</span></span>
        result.<span class="function"><span class="title">append</span><span class="params">(max_len)</span></span>
    return result

def <span class="function"><span class="title">match_str</span><span class="params">(long_str, short_str)</span></span>:
    p_long_str = <span class="number">0</span>
    count = <span class="number">0</span>
    ptm = <span class="function"><span class="title">partial_match_table</span><span class="params">(short_str)</span></span>
    while p_long_str &lt;= <span class="function"><span class="title">len</span><span class="params">(long_str)</span></span> - <span class="function"><span class="title">len</span><span class="params">(short_str)</span></span>:
        length =<span class="number">0</span>
        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(len(short_str)</span></span>):
            <span class="keyword">if</span> long_str[n + p_long_str] == short_str[n]:
                length = length +<span class="number">1</span>
            <span class="keyword">else</span>:
                break
        <span class="keyword">if</span> length == <span class="function"><span class="title">len</span><span class="params">(short_str)</span></span>:
            count = count +<span class="number">1</span>
            p_long_str = p_long_str + <span class="function"><span class="title">len</span><span class="params">(short_str)</span></span>
        elif length == <span class="number">0</span>:
            p_long_str = p_long_str +<span class="number">1</span>
        <span class="keyword">else</span>:
            p_long_str = p_long_str + length - ptm[length]

    return count

<span class="function"><span class="title">print</span><span class="params">(match_str(<span class="string">'ABC DACBD ABCDABD CCABCDABD'</span>, <span class="string">'ABCDABD'</span>)</span></span>)
</code></pre>
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2015-07-21-androide4b8ad-e5bcb1e68c87e99288-wpe79a84e4bd9ce794a8" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/21/2015-07-21-androide4b8ad-e5bcb1e68c87e99288-wpe79a84e4bd9ce794a8/" class="article-date">
  	<time datetime="2015-07-21T03:44:18.000Z" itemprop="datePublished">2015-07-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/21/2015-07-21-androide4b8ad-e5bcb1e68c87e99288-wpe79a84e4bd9ce794a8/">android中 弱指针 (wp)的作用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前一篇文章已经分析了强指针弱指针的实现原理。我们可以知道，android中的智能指针是通过引用计数的方式方式来实现内存自动回收的。在很多情况下我们使用强指针sp就好了，那么弱指针wp的存在意义有是什么呢？wp 弱指针 在什么样的情况下才会使用呢？为了直观地了解wp存在的意义，我们先分析下面的代码。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;utils/RefBase.h&gt;</span></span>

<span class="keyword">using</span> <span class="keyword">namespace</span> android;
<span class="keyword">class</span> LightClassTwo;

<span class="keyword">class</span> LightClassOne : <span class="keyword">public</span> RefBase {
  <span class="keyword">public</span>:
    LightClassOne() {
        <span class="built_in">printf</span>(<span class="string">"Construct LightClassOne Object.\n"</span>);
    }

    <span class="keyword">virtual</span> ~LightClassOne() {
        <span class="built_in">printf</span>(<span class="string">"Destory LightClassOne Object.\n"</span>);
    }
    <span class="function"><span class="keyword">void</span> <span class="title">setTwo</span><span class="params">(sp&lt;LightClassTwo&gt; two)</span> </span>{ mTwo = two; }
  <span class="keyword">private</span>:
    sp&lt;LightClassTwo&gt; mTwo;
};

<span class="keyword">class</span> LightClassTwo : <span class="keyword">public</span> RefBase {
  <span class="keyword">public</span>:
    LightClassTwo() {
        <span class="built_in">printf</span>(<span class="string">"Construct LightClassTwo Object.\n"</span>);
    }

    <span class="keyword">virtual</span> ~LightClassTwo() {
        <span class="built_in">printf</span>(<span class="string">"Destory LightClassTwo Object.\n"</span>);
    }
    <span class="function"><span class="keyword">void</span> <span class="title">setOne</span><span class="params">(sp&lt;LightClassOne&gt; one)</span> </span>{ mOne = one; }
  <span class="keyword">private</span>:
    <span class="comment">//wp&lt;LightClassOne&gt; mOne;</span>
    sp&lt;LightClassOne&gt; mOne;

};

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span>
</span>{
    LightClassOne* one = <span class="keyword">new</span> LightClassOne();
    LightClassTwo* two = <span class="keyword">new</span> LightClassTwo();

    <span class="built_in">printf</span>(<span class="string">"LightClassOne Light Ref Count: %d.\n"</span>, one-&gt;getStrongCount());
    <span class="built_in">printf</span>(<span class="string">"LightClassTwo Light Ref Count: %d.\n"</span>, two-&gt;getStrongCount());

    {
        sp&lt;LightClassTwo&gt; two_sp = two;
        sp&lt;LightClassOne&gt; one_sp = one;
        <span class="built_in">printf</span>(<span class="string">"LightClassOne Light Ref Count: %d.\n"</span>, one_sp-&gt;getStrongCount());
        <span class="built_in">printf</span>(<span class="string">"LightClassTwo Light Ref Count: %d.\n"</span>, two_sp-&gt;getStrongCount());
        two-&gt;setOne(one);
        one-&gt;setTwo(two);
        <span class="built_in">printf</span>(<span class="string">"LightClassOne Light Ref Count: %d.\n"</span>, one_sp-&gt;getStrongCount());
        <span class="built_in">printf</span>(<span class="string">"LightClassTwo Light Ref Count: %d.\n"</span>, two_sp-&gt;getStrongCount());
    }

    <span class="built_in">printf</span>(<span class="string">"LightClassOne Light Ref Count: %d.\n"</span>, one-&gt;getStrongCount());
    <span class="built_in">printf</span>(<span class="string">"LightClassTwo Light Ref Count: %d.\n"</span>, two-&gt;getStrongCount());

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>代码不复杂，代码中定义了两个类LightClassOne和LightClassTwo，他们都继承于RefBase，于是他们都具备了引用计数的能力。两个类除了构造析构函数外，还分别定义了对方类型的智能指针变量和相关的setXXX()函数。注意LightClassTwo中mOne对象现在是sp类型的。下面分析一下main函数的输出。</p>
<p>1.分别new出LightClassOne和LightClassTwo两个对象，此时构造函数调用，目前还没有任何智能指针指向这两个对象，因此强引用计数器的数值是初始值。</p>
<p>2.大括号里，分别构造两个sp指针指向这两个对象，强引用计数器加一，又是第一次有sp指向这两个对象，因此此时他们的强弱引用计数器是1。</p>
<p>3.分别互相调用setXXX()函数，在函数里面又有sp指向对象，强弱引用计数器继续增加，此时他们的强弱引用计数器是2。</p>
<p>4.跳出大括号时，最开始定义的两个sp(tow_sp/one_sp)对象要析构，所以他们所指对象的强弱引用计数器减1。</p>
<p>5.由于两个对象的强引用计数器都是1，他们互相持有对方，构成死锁，无法析构，直至程序跳出main函数结束。上述代码输出如下：</p>
<pre><code><span class="variable">Construct</span> <span class="variable">LightClassOne</span> <span class="variable">Object</span>.
<span class="variable">Construct</span> <span class="variable">LightClassTwo</span> <span class="variable">Object</span>.
<span class="variable">LightClassOne</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">268435456</span>.
<span class="variable">LightClassTwo</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">268435456</span>.
<span class="variable">LightClassOne</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">1</span>.
<span class="variable">LightClassTwo</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">1</span>.
<span class="variable">LightClassOne</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">2</span>.
<span class="variable">LightClassTwo</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">2</span>.
<span class="variable">LightClassOne</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">1</span>.
<span class="variable">LightClassTwo</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">1</span>.
</code></pre><p>因此，如果两个对象互相持有对方的强指针，就可能产生死锁，内存对象无法回收，造成内存泄漏。</p>
<p>为了解决这个问题，我们只需要将LightClassTwo中的mOne对象改为wp类型的即可。下面继续分析main函数的输出。</p>
<p>1.2步骤同上，不在赘述</p>
<p>3.分别互相调用setXXX()函数，LightClassOne持有的是LightClassTwo的强指针，因此对象two的强弱引用计数变为2，LightClassTwo持有的是LightClassOne的弱指针，因此对象one的强引用计数不变还是1，弱引用计数变为2。</p>
<p>4.跳出大括号时，最开始定义的两个sp(tow_sp/one_sp)对象要析构，所以他们所指对象的强弱引用计数器减1。此时two的强弱引用计数变为1。此时one的强引用计数为0，弱引用计数变为1。默认情况下，对象的生命周期受强引用计数控制，因此对象one开始析构。</p>
<p>5.随着对象one的析构，one持有的成员变量mTwo也要析构，因此two对象的强弱引用计数器减到0，two对象本身也要销毁了，析构函数调用。</p>
<p>6.此时最后两个printf函数打印出来的数值是随机值，因为one two都是野指针了。上述代码输出如下：</p>
<pre><code><span class="variable">Construct</span> <span class="variable">LightClassOne</span> <span class="variable">Object</span>.
<span class="variable">Construct</span> <span class="variable">LightClassTwo</span> <span class="variable">Object</span>.
<span class="variable">LightClassOne</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">268435456</span>.
<span class="variable">LightClassTwo</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">268435456</span>.
<span class="variable">LightClassOne</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">1</span>.
<span class="variable">LightClassTwo</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">1</span>.
<span class="variable">LightClassOne</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">1</span>.
<span class="variable">LightClassTwo</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">2</span>.
<span class="variable">Destory</span> <span class="variable">LightClassOne</span> <span class="variable">Object</span>.
<span class="variable">Destory</span> <span class="variable">LightClassTwo</span> <span class="variable">Object</span>.
<span class="variable">LightClassOne</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">1075955252</span>.
<span class="variable">LightClassTwo</span> <span class="variable">Light</span> <span class="variable">Ref</span> <span class="variable">Count</span>: <span class="number">1103936560</span>.
</code></pre><p>和我们的分析是一致的。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2015-07-17-androide699bae883bde68c87e99288sp-wpe58e9fe79086e58886e69e90" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/17/2015-07-17-androide699bae883bde68c87e99288sp-wpe58e9fe79086e58886e69e90/" class="article-date">
  	<time datetime="2015-07-16T21:37:02.000Z" itemprop="datePublished">2015-07-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/17/2015-07-17-androide699bae883bde68c87e99288sp-wpe58e9fe79086e58886e69e90/">android智能指针(sp wp)原理分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>一. 前言</strong></p>
<p>Android的native代码使用C++编写的。C++最让程序员头疼的事情就是对象的管理，即动态内存的分配与释放。一方面C++的这种灵活性可以为编程带来更大的自由，另一方面这种自由也带来了一些风险，稍有不慎，就可能造成内存泄漏甚至是程序崩溃。Java语言有GC（垃圾回收）机制，可以让程序员不用考虑对象生命周期的管理，虽然这对程序性能会造成一定的损失。那么如何既能发挥C++的性能优势，又能让程序自动管理对象的生命周期呢。智能指针就是为此而生的。这里我们将讨论android系统中智能指针，也就是我们常见的sp（强指针）wp（弱指针）的实现原理。</p>
<p>智能指针的实现一般都采用引用计数技术的方案。Android智能指针实现方案既包括简单的引用计数技术，也包括了复杂的引用计数技术（强引用计数，弱引用计数）。智能指针相关代码的路径是（android 5.0）：</p>
<pre><code>system<span class="regexp">/core/</span>include<span class="regexp">/utils/</span>RefBase.h
system<span class="regexp">/core/</span>libutils/RefBase.cpp
system<span class="regexp">/core/</span>include<span class="regexp">/utils/</span>StrongPointer.h
</code></pre><p>三个文件都不大，却包含了Android系统强大的智能指针的实现，其中的几个模板类：LightRefBase、RefBase、sp、wp组成了Android智能指针的框架，前两个是引用计数基类，后两个是智能指针类。要说明的是：任何想要使用Android智能指针的类都必须继承或者间接继承于LightRefBase/RefBase这两个基类。下面将着重分析这几个模板类。</p>
<p>PS：下面帖的代码基本上都是精简过的，去除了一些用于Debug的代码，便于分析本质。</p>
<p><strong>二. LightRefBase</strong></p>
<p>首先来分析一下Android智能指针的轻量级实现LightRefBase，他的代码在RefBase.h中：</p>
<pre><code>template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;
<span class="title">class</span> <span class="title">LightRefBase</span>
</span>{
  <span class="keyword">public</span>:
    <span class="function">inline <span class="title">LightRefBase</span><span class="params">()</span> : <span class="title">mCount</span><span class="params">(<span class="number">0</span>)</span> </span>{ }
    <span class="function">inline <span class="keyword">void</span> <span class="title">incStrong</span><span class="params">(__attribute__((unused)</span>) <span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span> </span>{
    android_atomic_inc(&amp;mCount);
    }
    <span class="function">inline <span class="keyword">void</span> <span class="title">decStrong</span><span class="params">(__attribute__((unused)</span>) <span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span> </span>{
        <span class="keyword">if</span> (android_atomic_dec(&amp;mCount) == <span class="number">1</span>) {
            delete static_cast&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);
        }
    }
    <span class="comment">//! DEBUGGING ONLY: Get current strong ref count.</span>
    <span class="function">inline int32_t <span class="title">getStrongCount</span><span class="params">()</span> <span class="keyword">const</span> </span>{
        <span class="keyword">return</span> mCount;
    }

  <span class="keyword">protected</span>:
    inline ~LightRefBase() { }

 <span class="keyword">private</span>:
    mutable <span class="keyword">volatile</span> int32_t mCount;

};
</code></pre><p>类的声明和实现全都在这里了，简单来看，这个类包含了一个成员变量引用计数器mCount，两个用来维护引用计数器值的成员函数incStrong和decStrong。基类只是提供了引用计数的能力，要实现内存对象的自动回收，还必须配合智能指针类（也就是sp、wp）管理引用计数。这里不想过早地引入智能指针类，但是为了对LightRefBase如何配合智能指针完成内存的自动回收有个大概的理解，我们一起来对以下伪代码运行的过程进行脑补：</p>
<pre><code><span class="collection">{
    LightClass* pLightClass = new LightClass<span class="list">()</span><span class="comment">;</span>
    smart_ptr&lt;LightClass&gt; lsp = pLightClass;
    printf<span class="list">(<span class="string">"Light Ref Count: %d.\n"</span>, pLightClass-&gt;getStrongCount<span class="list">()</span>)</span><span class="comment">;</span>
}</span>
</code></pre><p>1.LightClass继承于LightRefBase，LightClass构造的时候调用父类LightRefBase的构造函数，mCount初始化为0。<br>2.smart_ptr是智能指针类，智能指针利用LightClass的指针pLightClass构造出lsp。为了利用LightRefBase中的引用计数器，smart_ptr类构造的过程中会调用LightRefBase的incStrong函数使mCount加1。<br>3.从大括号跳出后，局部变量lsp要析构，smart_ptr类的析构函数中会调用LightRefBase的decStrong函数使mCount减1，并判断mCount是否为0，若为0，直接调用delete释放LightClass类new出来的对象。</p>
<p>这样new出来的LightClass对象就不需要显示地调用delete来回收内存，而是通过智能指针利用引用计数来决定何时释放内存。以简单的引用计数技术方式实现的智能指针似乎够用了吧，为什么还有下面的复杂的引用计数技术方式实现的智能指针呢？因为LightRefBase没有办法解决对象间循环引用的情况。下面会给出示例。至此，只需要记住LightRefBase拥有一个引用计数器mCount和两个用来维护引用计数器值的函数incStrong/decStrong即可。</p>
<p><strong>三. RefBase</strong></p>
<p>RefBase比LightRefBase从名字上看少了Light，那应该复杂很多吧。看下RefBase类的声明：</p>
<pre><code><span class="keyword">class</span> RefBase
{
  <span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;

    <span class="function"><span class="keyword">void</span> <span class="title">forceIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;
    <span class="comment">//! DEBUGGING ONLY: Get current strong ref count.</span>
    <span class="keyword">int32_t</span>         getStrongCount() <span class="keyword">const</span>;
    <span class="keyword">class</span> weakref_type
    {
      <span class="keyword">public</span>:
        <span class="function">RefBase* <span class="title">refBase</span><span class="params">()</span> <span class="keyword">const</span></span>;

        <span class="function"><span class="keyword">void</span> <span class="title">incWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;
        <span class="function"><span class="keyword">void</span> <span class="title">decWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;

        <span class="comment">// acquires a strong reference if there is already one.</span>
        <span class="function"><span class="keyword">bool</span> <span class="title">attemptIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;

        <span class="comment">// acquires a weak reference if there is already one.</span>
        <span class="comment">// This is not always safe. see ProcessState.cpp and BpBinder.cpp</span>
        <span class="comment">// for proper use.</span>
        <span class="function"><span class="keyword">bool</span> <span class="title">attemptIncWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;

        <span class="comment">//! DEBUGGING ONLY: Get current weak ref count.</span>
        <span class="keyword">int32_t</span> getWeakCount() <span class="keyword">const</span>;

    };
    <span class="function">weakref_type*   <span class="title">createWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;
    <span class="function">weakref_type*   <span class="title">getWeakRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;
    <span class="keyword">typedef</span> RefBase basetype;

  <span class="keyword">protected</span>:
    RefBase();
    <span class="keyword">virtual</span> ~RefBase();
    <span class="comment">//! Flags for extendObjectLifetime()</span>
    <span class="keyword">enum</span> {
        OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,
        OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,
        OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span>
    };
    <span class="function"><span class="keyword">void</span> <span class="title">extendObjectLifetime</span><span class="params">(int32_t mode)</span></span>;
    <span class="comment">//! Flags for onIncStrongAttempted()</span>
    <span class="keyword">enum</span> {
        FIRST_INC_STRONG = <span class="number">0x0001</span>
    };

    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onFirstRef</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">onIncStrongAttempted</span><span class="params">(uint32_t flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;

  <span class="keyword">private</span>:
    <span class="keyword">friend</span> <span class="keyword">class</span> weakref_type;
    <span class="keyword">class</span> weakref_impl;

    RefBase(<span class="keyword">const</span> RefBase&amp; o);
    RefBase&amp;        <span class="keyword">operator</span>=(<span class="keyword">const</span> RefBase&amp; o);
    weakref_impl* <span class="keyword">const</span> mRefs;
};
</code></pre><p>RefBase类确实要复杂一些，他没有mCount，成员变量也只有一个weakref_impl类型的mRefs,看来这个mRefs就是实现引用计数的关键了。此外还有一些关键的控制引用计数的方法incStrong、decStrong、forceIncStrong、createWeak。weakref_type内部类，看起来和weakref_impl类型的mRefs有些关系。enum变量(OBJECT_LIFETIME_STRONG、OBJECT_LIFETIME_WEAK、OBJECT_LIFETIME_MASK)指示了维护对象引用计数所使用的策略，后面会解释他们的具体涵义。以onXXX开头的回调函数了，他们可以被继承于RefBase的子类重写。</p>
<p>和引用计数相关的变量mRefs是weakref_impl类型的，所以要先研究下这个weakref_impl类。他的定义在RefBas.cpp文件中。</p>
<pre><code><span class="keyword">class</span> RefBase::weakref_impl : <span class="keyword">public</span> RefBase::weakref_type
{
  <span class="keyword">public</span>:
    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mStrong;
    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mWeak;
    RefBase* <span class="keyword">const</span> mBase;
    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> mFlags;

    weakref_impl(RefBase* base)
    : mStrong(INITIAL_STRONG_VALUE)
    , mWeak(<span class="number">0</span>)
    , mBase(base)
    , mFlags(<span class="number">0</span>)
    {
    }
};
</code></pre><p>weakref_impl类继承于weakref_type，从类名上看weakref_type是接口，weakref_impl是具体实现。但是去除了debug用的相关代码后，weakref_impl显得十分单薄，一些关键的方法（incWeak、decWeak、attemptIncStrong、attemptIncWeak）也还是在父类中实现的。不管怎样先专注于weakref_impl，他定义了以下变量，并在构造函数中初始化：</p>
<p>1.mStrong 强引用计数器<br>2.mWeak 弱引用计数器<br>3.mBase 指向外部类对象，也就是原始对象的指针<br>4.mFlags 控制引用计数使用策略，取值是RefBase中定义的enum值</p>
<p>和LightRefBase只有一个mCount引用计数器不同，RefBase定义了weakref_impl类型的mRefs变量，并持有mStrong强引用计数器和mWeak弱引用计数器，配合mFlags控制引用计数使用策略，为实现更为强大的智能指针奠定了基础。下面将介绍智能指针类sp、wp，一览Android智能指针的全貌。</p>
<p><strong>四. sp强指针</strong></p>
<p>前面介绍的LightRefBase和RefBase只是基类，他们提供了引用计数的能力，必须配合智能指针类，才能实现内存对象的自动管理。这里先介绍sp强指针，他的类声明在StrongPointer.h中：</p>
<pre><code>template&lt;typename T&gt;
<span class="keyword">class</span> <span class="title">sp</span> {
  <span class="keyword">public</span>:
    <span class="function">inline <span class="title">sp</span>(<span class="params"></span>) : <span class="title">m_ptr</span>(<span class="params"><span class="number">0</span></span>) </span>{ }
    sp(T* other);
    sp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other);
    template&lt;typename U&gt; sp(U* other);
    template&lt;typename U&gt; sp(<span class="keyword">const</span> sp&lt;U&gt;&amp; other);

    ~sp();

    <span class="comment">// Assignment</span>
    sp&amp; <span class="keyword">operator</span> = (T* other);
    sp&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> sp&lt;T&gt;&amp; other);
    template&lt;typename U&gt; sp&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> sp&lt;U&gt;&amp; other);
    template&lt;typename U&gt; sp&amp; <span class="keyword">operator</span> = (U* other);
    <span class="comment">//! Special optimization for use by ProcessState (and nobody else).</span>
    <span class="function"><span class="keyword">void</span> <span class="title">force_set</span>(<span class="params">T* other</span>)</span>;

    <span class="comment">// Reset</span>
    <span class="function"><span class="keyword">void</span> <span class="title">clear</span>(<span class="params"></span>)</span>;

    <span class="comment">// Accessors</span>
    inline T&amp; <span class="keyword">operator</span>* () <span class="keyword">const</span>  { <span class="keyword">return</span> *m_ptr; }
    inline T* <span class="keyword">operator</span>-&gt; () <span class="keyword">const</span> { <span class="keyword">return</span> m_ptr;  }
    inline T* <span class="keyword">get</span>() <span class="keyword">const</span> { <span class="keyword">return</span> m_ptr; }

    <span class="comment">// Operators</span>
    COMPARE(==)
    COMPARE(!=)
    COMPARE(&gt;)
    COMPARE(&lt;)
    COMPARE(&lt;=)
    COMPARE(&gt;=)

  <span class="keyword">private</span>:
    template&lt;typename Y&gt; friend <span class="keyword">class</span> <span class="title">sp</span>;
    template&lt;typename Y&gt; friend <span class="keyword">class</span> <span class="title">wp</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">set_pointer</span>(<span class="params">T* ptr</span>)</span>;

    T* m_ptr;
};
</code></pre><p>这里声明了一些构造函数，重载了一些运算符，定义了指向真实对象的变量m_ptr。sp中重载了运算符“*”和“-&gt;”还有get()函数，因此我们可以像用普通指针那样利用sp操作原始对象。首先分析仪下sp的构造函数、析构函数、重载赋值运算符。</p>
<pre><code>template&lt;typename T&gt;
sp&lt;T&gt;::sp(T* other)
    : m_ptr(other) {
    <span class="keyword">if</span> (other)
        other-&gt;incStrong(<span class="keyword">this</span>);
}
</code></pre><p>T必然是继承于RefBase或者LightRefBase的，以真实对象的指针为参数构造sp对象，如果指针不是NULL，调用对象的incStrong函数增加引用计数。</p>
<pre><code>template&lt;typename T&gt;
sp&lt;T&gt;::sp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other)
    : m_ptr(other.m_ptr) {
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;incStrong(<span class="keyword">this</span>);
}
</code></pre><p>复制构造函数，如果m_ptr不是NULL，调用对象的incStrong函数增加引用计数。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
sp&lt;T&gt;::sp(U* other)
    : m_ptr(other) {
    <span class="keyword">if</span> (other)
        ((T*) other)-&gt;incStrong(<span class="keyword">this</span>);
}
</code></pre><p>和第一个构造函数类似，U和T具有继承关系。比如定义了sp<t>对象，new出的对象是U类型的，U是T的子类（只要强制转换能成功），可以利用U类型对象创建sp<t>对象。</t></t></p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
sp&lt;T&gt;::sp(<span class="keyword">const</span> sp&lt;U&gt;&amp; other)
    : m_ptr(other.m_ptr) {
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;incStrong(<span class="keyword">this</span>);
}
</code></pre><p>和第二个构造函数类似，U和T具有继承关系。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
sp&lt;T&gt;::~sp() {
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;decStrong(<span class="keyword">this</span>);
}
</code></pre><p>sp对象析构的时候，如果m_ptr不是NULL，调用对象的decStrong函数减少引用计数。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
sp&lt;T&gt;&amp; sp&lt;T&gt;::<span class="keyword">operator</span> =(<span class="keyword">const</span> sp&lt;T&gt;&amp; other) {
    <span class="function">T* <span class="title">otherPtr</span><span class="params">(other.m_ptr)</span></span>;
    <span class="keyword">if</span> (otherPtr)
        otherPtr-&gt;incStrong(<span class="keyword">this</span>);
    <span class="keyword">if</span> (m_ptr)
    m_ptr-&gt;decStrong(<span class="keyword">this</span>);
    m_ptr = otherPtr;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>重载赋值运算符，增加other所指向对象的引用计数，如果这个sp对象之前指向了其他对象，还需要减少那个对象的引用计数。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
sp&lt;T&gt;&amp; sp&lt;T&gt;::<span class="keyword">operator</span> =(T* other) {
    <span class="keyword">if</span> (other)
        other-&gt;incStrong(<span class="keyword">this</span>);
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;decStrong(<span class="keyword">this</span>);
    m_ptr = other;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>重载赋值运算符，增加other对象的引用计数，如果这个sp对象之前指向了其他对象，还需要减少那个对象的引用计数。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
sp&lt;T&gt;&amp; sp&lt;T&gt;::<span class="keyword">operator</span> =(<span class="keyword">const</span> sp&lt;U&gt;&amp; other) {
    <span class="function">T* <span class="title">otherPtr</span><span class="params">(other.m_ptr)</span></span>;
    <span class="keyword">if</span> (otherPtr)
        otherPtr-&gt;incStrong(<span class="keyword">this</span>);
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;decStrong(<span class="keyword">this</span>);
    m_ptr = otherPtr;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>同上，U和T具有继承关系。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
sp&lt;T&gt;&amp; sp&lt;T&gt;::<span class="keyword">operator</span> =(U* other) {
    <span class="keyword">if</span> (other)
        ((T*) other)-&gt;incStrong(<span class="keyword">this</span>);
    <span class="keyword">if</span> (m_ptr)
        m_ptr-&gt;decStrong(<span class="keyword">this</span>);
    m_ptr = other;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>同上，U和T具有继承关系。</p>
<p>下面着重分析incStrong和decStrong两个函数，因为LightRefBase中这两个函数的实现十分简单，这里就不赘述了，只分析RefBase的incStrong和decStrong<br>incStrong：</p>
<pre><code>void RefBase::incStrong(<span class="keyword">const</span> void* id) <span class="keyword">const</span>
{
    weakref_impl* <span class="keyword">const</span> refs = mRefs;
    refs-&gt;incWeak(id);
    <span class="keyword">const</span> int32_t c = android_atomic_inc(&amp;refs-&gt;mStrong);
    <span class="keyword">if</span> (c != INITIAL_STRONG_VALUE)  {
        <span class="keyword">return</span>;
    }
    android_atomic_add(-INITIAL_STRONG_VALUE, &amp;refs-&gt;mStrong);
    refs-&gt;mBase-&gt;onFirstRef();
}
</code></pre><p>RefBase中和引用计数相关的变量是mRefs，首先调用weakref_type的incWeak函数</p>
<pre><code><span class="keyword">void</span> RefBase::weakref_type::incWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)
{
    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);
    <span class="keyword">const</span> <span class="keyword">int32_t</span> c __unused = android_atomic_inc(&amp;impl-&gt;mWeak);
}
</code></pre><p>这个函数所做的是增加mRefs的mWeak变量值。</p>
<p>然后调用android_atomic_inc(&amp;refs-&gt;mStrong)增加mRefs的mStrong变量值。c返回增加之前的值。<br>如果c不是INITIAL_STRONG_VALUE，直接返回。如果c是INITIAL_STRONG_VALUE，说明这个对象的强引用计数是第一次增加，mStrong的初始值是INITIAL_STRONG_VALUE，通过调用<br>android_atomic_add(-INITIAL_STRONG_VALUE, &amp;refs-&gt;mStrong);<br>让mStrong的值变为1。同时如果有需要的话还可以调用重写的onFirstRef()回调函数。</p>
<p>decStrong：</p>
<pre><code><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span>
{
    weakref_impl* <span class="keyword">const</span> refs = mRefs;
    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);
    <span class="keyword">if</span> (c == <span class="number">1</span>) {
        refs-&gt;mBase-&gt;onLastStrongRef(id);
        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) {
            <span class="keyword">delete</span> <span class="keyword">this</span>;
        }
    }
    refs-&gt;decWeak(id);
}
</code></pre><p>首先减少mRefs的mStrong变量值，如果返回值c等于1，说明现在mStrong是0，对象内存有被释放掉的可能。<br>调用完onLastStrongRef()回调函数后，判断mFlags的取值，如果是OBJECT_LIFETIME_STRONG，则说明对象生命周期受强引用计数控制，强引用计数为0，则原始对象就要被delete掉了。<br>不管原始对象有没有被delete掉，还是会调用decWeak见少弱引用计数的。</p>
<pre><code><span class="keyword">void</span> RefBase::weakref_type::decWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id)
{
    weakref_impl* <span class="keyword">const</span> impl = <span class="keyword">static_cast</span>&lt;weakref_impl*&gt;(<span class="keyword">this</span>);
    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;impl-&gt;mWeak);
    <span class="keyword">if</span> (c != <span class="number">1</span>) <span class="keyword">return</span>;
    <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) {
        <span class="comment">// This is the regular lifetime case. The object is destroyed</span>
        <span class="comment">// when the last strong reference goes away. Since weakref_impl</span>
        <span class="comment">// outlive the object, it is not destroyed in the dtor, and</span>
        <span class="comment">// we'll have to do it here.</span>
        <span class="keyword">if</span> (impl-&gt;mStrong == INITIAL_STRONG_VALUE) {
            <span class="comment">// Special case: we never had a strong reference, so we need to</span>
            <span class="comment">// destroy the object now.</span>
            <span class="keyword">delete</span> impl-&gt;mBase;
        } <span class="keyword">else</span> {
            <span class="comment">// ALOGV("Freeing refs %p of old RefBase %p\n", this, impl-&gt;mBase);</span>
            <span class="keyword">delete</span> impl;
        }
    } <span class="keyword">else</span> {
        <span class="comment">// less common case: lifetime is OBJECT_LIFETIME_{WEAK|FOREVER}</span>
        impl-&gt;mBase-&gt;onLastWeakRef(id);
        <span class="keyword">if</span> ((impl-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_WEAK) {
            <span class="comment">// this is the OBJECT_LIFETIME_WEAK case. The last weak-reference</span>
            <span class="comment">// is gone, we can destroy the object.</span>
            <span class="keyword">delete</span> impl-&gt;mBase;
        }
    }
}
</code></pre><p>decWeak函数首先减少mWeak的值，如果mWeak不是0，直接退出。如果mWeak是0，就要根据策略来决定是否要释放对象内存了。</p>
<p>如果mFlags是OBJECT_LIFETIME_STRONG，分两种情况：<br>1.mStrong从未增加仍然是初始值，说明没有任何sp指向过这个对象，只有弱指针指向过这个对象，因此，直接删除原始对象。在Refbase的析构函数中，delete变量mRefs。<br>2.mStrong不是初始值，说明此时mStrong一定是0，因为sp构造时会同时增加强指针计数和弱指针计数，析构时会减少强指针计数和弱指针计数，wp构造时只会增加弱引用技术，析构时只会减少弱指针计数。所以这里mWeak是0，mStrong一定是0。前面在decStrong中原始对象已经被delete掉了，这里只需要delete掉在RefBase中new出来的对象mRefs即可。Refbase的析构函数中也会尝试delete成员变量mRefs，但需要判断条件mRefs-&gt;mWeak为0，这种情形下，mWeak是在delete原始对象后减为0的，条件不成里。</p>
<pre><code>RefBase::~RefBase()
{
    <span class="keyword">if</span> (mRefs-&gt;mStrong == INITIAL_STRONG_VALUE) {
        <span class="comment">// we never acquired a strong (and/or weak) reference on this object.</span>
        <span class="keyword">delete</span> mRefs;
    } <span class="keyword">else</span> {
        <span class="comment">// life-time of this object is extended to WEAK or FOREVER, in</span>
        <span class="comment">// which case weakref_impl doesn't out-live the object and we</span>
        <span class="comment">// can free it now.</span>
        <span class="keyword">if</span> ((mRefs-&gt;mFlags &amp; OBJECT_LIFETIME_MASK) != OBJECT_LIFETIME_STRONG) {
            <span class="comment">// It's possible that the weak count is not 0 if the object</span>
            <span class="comment">// re-acquired a weak reference in its destructor</span>
            <span class="keyword">if</span> (mRefs-&gt;mWeak == <span class="number">0</span>) {
                <span class="keyword">delete</span> mRefs;
            }
        }
    }
}

}
</code></pre><p>如果mFlags是OBJECT_LIFETIME_WEAK，那么decStrong中就不会因为mStrong为0就把原始对象释放掉，必须要求mWeak为0才会delete对象，mRefs的变量mBase指向原始对象。此时在Refbase的析构函数，mRefs-&gt;mWeak为0，因此会delete变量mRefs。</p>
<p>通古上面的分析，这里总结下mFlags取值的涵义：<br>OBJECT_LIFETIME_STRONG：强引用计数控制真实对象的生命周期，弱引用计数控制weakref_impl类型对象mRefs的生命周期。强引用计数为0后，实际对象被delete。弱引用计数为0后，mRefs对象被delete。<br>OBJECT_LIFETIME_WEAK：强引用计数为0，弱引用计数不为0时，实际对象不会被delete。当弱引用计数减为0时，实际对象和mRefs对象会同时被delete。<br>mFlags的默认值是0，即是OBJECT_LIFETIME_STRONG。如果想要改变策略，需要调用RefBase的protected的函数extendObjectLifetime(int32_t mode)设置mFlags的值。</p>
<p><strong>五. wp弱指针</strong></p>
<p>下面开始分析弱指针wp，他的定义在RefBase.h文件中。</p>
<pre><code>template &lt;typename T&gt;
<span class="class"><span class="keyword">class</span> <span class="title">wp</span>
</span>{
  public:
    <span class="literal">typedef</span> typename RefBase::weakref_type weakref_type;

    inline wp() : m_ptr(<span class="number">0</span>) { }

    wp(T* other);
    wp(<span class="keyword">const</span> wp&amp; other);
    wp(<span class="keyword">const</span> sp&amp; other);
    template wp(U* other);
    template wp(<span class="keyword">const</span> sp&lt;u&gt;&amp; other);
    template wp(<span class="keyword">const</span> wp&lt;u&gt;&amp; other);

    ~wp();

    <span class="comment">// Assignment</span>

    wp&amp; <span class="literal">operator</span> = (T* other);
    wp&amp; <span class="literal">operator</span> = (<span class="keyword">const</span> wp&amp; other);
    wp&amp; <span class="literal">operator</span> = (<span class="keyword">const</span> sp&amp; other);

    template wp&amp; <span class="literal">operator</span> = (U* other);
    template wp&amp; <span class="literal">operator</span> = (<span class="keyword">const</span> wp&lt;u&gt;&amp; other);
    template wp&amp; <span class="literal">operator</span> = (<span class="keyword">const</span> sp&lt;u&gt;&amp; other);

    <span class="keyword">void</span> set_object_and_refs(T* other, weakref_type* refs);

    <span class="comment">// promotion to sp</span>

    sp promote() <span class="keyword">const</span>;

    <span class="comment">// Reset</span>

    <span class="keyword">void</span> clear();

    <span class="comment">// Accessors</span>

    inline  weakref_type* get_refs() <span class="keyword">const</span> { <span class="keyword">return</span> m_refs; }

    inline  T* unsafe_get() <span class="keyword">const</span> { <span class="keyword">return</span> m_ptr; }

    <span class="comment">// Operators</span>

    COMPARE_WEAK(==)
    COMPARE_WEAK(!=)
    COMPARE_WEAK(&gt;)
    COMPARE_WEAK(&lt;)
    COMPARE_WEAK(&lt;=)     COMPARE_WEAK(&gt;=)

    inline <span class="built_in">bool</span> <span class="literal">operator</span> == (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> (m_ptr == o.m_ptr) &amp;&amp; (m_refs == o.m_refs);
    }
    template
    inline <span class="built_in">bool</span> <span class="literal">operator</span> == (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> m_ptr == o.m_ptr;
    }

    inline <span class="built_in">bool</span> <span class="literal">operator</span> &gt; (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> (m_ptr == o.m_ptr) ? (m_refs &gt; o.m_refs) : (m_ptr &gt; o.m_ptr);
    }
    template
    inline <span class="built_in">bool</span> <span class="literal">operator</span> &gt; (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> (m_ptr == o.m_ptr) ? (m_refs &gt; o.m_refs) : (m_ptr &gt; o.m_ptr);
    }

    inline <span class="built_in">bool</span> <span class="literal">operator</span> &lt; (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> (m_ptr == o.m_ptr) ? (m_refs &lt; o.m_refs) : (m_ptr &lt; o.m_ptr);
    }
    template
    inline <span class="built_in">bool</span> <span class="literal">operator</span> &lt; (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> {
        <span class="keyword">return</span> (m_ptr == o.m_ptr) ? (m_refs &lt; o.m_refs) : (m_ptr &lt; o.m_ptr);
    }
                         inline <span class="built_in">bool</span> <span class="literal">operator</span> != (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> m_refs != o.m_refs; }
    template inline <span class="built_in">bool</span> <span class="literal">operator</span> != (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> !<span class="literal">operator</span> == (o); }
                         inline <span class="built_in">bool</span> <span class="literal">operator</span> &lt;= (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> !<span class="literal">operator</span> &gt; (o); }
    template inline <span class="built_in">bool</span> <span class="literal">operator</span> &lt;= (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> !<span class="literal">operator</span> &gt; (o); }
                         inline <span class="built_in">bool</span> <span class="literal">operator</span> &gt;= (<span class="keyword">const</span> wp&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> !<span class="literal">operator</span> &lt; (o); }
    template inline <span class="built_in">bool</span> <span class="literal">operator</span> &gt;= (<span class="keyword">const</span> wp&lt;u&gt;&amp; o) <span class="keyword">const</span> { <span class="keyword">return</span> !<span class="literal">operator</span> &lt; (o); }

  private:
    template friend <span class="class"><span class="keyword">class</span> <span class="title">sp</span>;
    <span class="title">template</span> <span class="title">friend</span> <span class="title">class</span> <span class="title">wp</span>;

    <span class="title">T</span>*              <span class="title">m_ptr</span>;
    <span class="title">weakref_type</span>*   <span class="title">m_refs</span>;
};&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;&lt;/<span class="title">u</span>&gt;</span>
</code></pre><p>和sp一样，这里声明了一些构造函数，重载了一些运算符，定义了指向真实对象的变量m_ptr。但是wp中并没有重载“*”和“-&gt;”运算符，能获取原始对象的也只有一个unsafe_get()函数，因此我们是不能利用wp直接操作对象的。此外还有类型是weakref_type成员变量m_refs。下面来分析几个典型的wp的构造函数和析构函数</p>
<pre><code>template&lt;typename T&gt;

wp&lt;T&gt;::wp(T* other)
: m_ptr(other)
{
    <span class="keyword">if</span> (other) m_refs = other-&gt;createWeak(<span class="keyword">this</span>);
}
</code></pre><p>用原始对象的指针为参数构造wp，如果other不为NULL，则调用原始对象的createWeak，返回值赋予m_refs。看来createWeak函数比较关键。</p>
<pre><code>template&lt;typename T&gt;
wp&lt;T&gt;::wp(<span class="keyword">const</span> wp&lt;T&gt;&amp; other)
: m_ptr(other.m_ptr), m_refs(other.m_refs)
{
    <span class="keyword">if</span> (m_ptr) m_refs-&gt;incWeak(<span class="keyword">this</span>);
}
</code></pre><p>复制构造函数，调用m_ref的incWeak增加弱引用计数。</p>
<pre><code>template&lt;typename T&gt;
wp&lt;T&gt;::wp(<span class="keyword">const</span> sp&lt;T&gt;&amp; other)
: m_ptr(other.m_ptr)
{
    <span class="keyword">if</span> (m_ptr) {
        m_refs = m_ptr-&gt;createWeak(<span class="keyword">this</span>);
    }
}
</code></pre><p>用强指针对象为参数构造wp，强指针指向的真实对象指针赋予弱指针的m_ptr，同时调用createWeak。</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
wp&lt;T&gt;::~wp()
{
    <span class="keyword">if</span> (m_ptr) m_refs-&gt;decWeak(<span class="keyword">this</span>);
}
</code></pre><p>wp析构时调用decWeak减少弱引用计数</p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
wp&lt;T&gt;&amp; wp&lt;T&gt;::<span class="keyword">operator</span> = (T* other)
{
    weakref_type* newRefs = other ? other-&gt;createWeak(<span class="keyword">this</span>) : <span class="number">0</span>;
    <span class="keyword">if</span> (m_ptr) m_refs-&gt;decWeak(<span class="keyword">this</span>);
    m_ptr = other;
    m_refs = newRefs;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>重载赋值运算符，新指向的对象调用createWeak，原来指向的对象减少弱引用计数，更新相关指针指向的对象。</p>
<p>看来wp中比较关键的几个方法是createWeak、incWeak、decWeak。incWeak、decWeak前面已经分析过了，下面将分别分析createWeak。</p>
<pre><code>RefBase::weakref_type* RefBase::createWeak(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span>
{
    mRefs-&gt;incWeak(id);
    <span class="keyword">return</span> mRefs;
}
</code></pre><p>createWeak是RefBase中的方法，他会调用incWeak增加对象的弱引用计数。同时将对象的mRefs返回，并赋给wp中定义的成员变量m_refs。于是，wp对象中有了一个原始对象mRefs指针变量的副本。改变弱引用计数的相关函数incWeak、decWeak是定义在weakref_type中的，因此wp需要weakref_type类型的变量去调用这些函数。改变强引用计数的相关函数incStrong、decStrong是定义在RefBase中的，因此sp不需要weakref_type类型的变量。</p>
<p>前面已经说过了，wp没法直接用来操作原始对象，虽然他可能指向了一个确实存在的原始对象，要想访问wp指向的这个原始对象，必须用promote函数将wp提升为sp，然后通过sp来访问。于是关键就在于这个promote函数，下面来分析这个函数。</p>
<pre><code><span class="keyword">template</span>&lt;typename T&gt;

sp&lt;T&gt; wp&lt;T&gt;::promote() <span class="keyword">const</span>
{
    sp&lt;T&gt; <span class="literal">result</span>;
    <span class="keyword">if</span> (m_ptr &amp;&amp; m_refs-&gt;attemptIncStrong(&amp;<span class="literal">result</span>)) {
        <span class="literal">result</span>.set_pointer(m_ptr);
    }
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>result将调用sp的默认构造函数，他的成员变量m_pt会初始化为NULL，因此如果promote不成功，将返回一个指向为NULL的sp。</p>
<p>m_ptr是NULL的情况只有用户自己传给了wp一个NULL指针构造wp，否则m_ptr不为NULL，但是他可能指向一个已经被delete掉的对象，所以要调用后面的attemptIncStrong函数继续进行判断。</p>
<p>什么情况下会出现wp指向一个已经被delete掉的对象的情况呢，看下面的代码。</p>
<pre><code>{
    <span class="keyword">A</span>* a = new <span class="keyword">A</span>()<span class="comment">;</span>
    wp&lt;<span class="keyword">A</span>&gt; m_wp(a)<span class="comment">;</span>
    {
        sp&lt;<span class="keyword">A</span>&gt; m_sp = a<span class="comment">;</span>
    }
    sp&lt;<span class="keyword">A</span>&gt;m_promote_wp = m_wp.promote()<span class="comment">;</span>
}
</code></pre><p>m_wp构造时会增加弱引用计数，此时弱引用计数为1。sp构造时会增加强引用计数和弱引用计数，此时强引用计数为1，弱引用计数为2。<br>m_sp从大括号中出来时会调用sp的析构函数，同时减少强引用计数和弱引用计数，此时强引用计数为0，弱引用计数为1。<br>根据前面对decStrong的分析，如果对象受强引用计数控制，即mFlags为OBJECT_LIFETIME_STRONG，则会delete掉真实对象。这时调用promote，就会失败得到一个指向NULL的sp。<br>下面着重分析attemptIncStrong是如何运作的。</p>
<pre><code><span class="keyword">bool</span> RefBase::weakref_type::attemptIncStrong(<span class="keyword">const</span> void* id)
{
    incWeak(id);

    weakref_impl* <span class="keyword">const</span> <span class="keyword">impl</span> = static_cast&lt;weakref_impl*&gt;(this);
    int32_t curCount = <span class="keyword">impl</span>-&gt;mStrong;

    <span class="keyword">while</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount != INITIAL_STRONG_VALUE) {
        <span class="comment">// we're in the easy/common case of promoting a weak-reference</span>
        <span class="comment">// from an existing strong reference.</span>
        <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount+<span class="number">1</span>, &amp;<span class="keyword">impl</span>-&gt;mStrong) == <span class="number">0</span>) {
            <span class="keyword">break</span>;
        }
        <span class="comment">// the strong count has changed on us, we need to re-assert our</span>
        <span class="comment">// situation.</span>
        curCount = <span class="keyword">impl</span>-&gt;mStrong;
    }

    <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span> || curCount == INITIAL_STRONG_VALUE) {         
        <span class="comment">// we're now in the harder case of either:         </span>
        <span class="comment">// - there never was a strong reference on us         </span>
        <span class="comment">// - or, all strong references have been released         </span>
        <span class="keyword">if</span> ((<span class="keyword">impl</span>-&gt;mFlags&amp;OBJECT_LIFETIME_WEAK) == OBJECT_LIFETIME_STRONG) {
            <span class="comment">// this object has a "normal" life-time, i.e.: it gets destroyed</span>
            <span class="comment">// when the last strong reference goes away</span>
            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) {                 
                <span class="comment">// the last strong-reference got released, the object cannot                 </span>
                <span class="comment">// be revived.                 </span>
                decWeak(id);                 
                <span class="keyword">return</span> <span class="keyword">false</span>;            
            }             
            <span class="comment">// here, curCount == INITIAL_STRONG_VALUE, which means             </span>
            <span class="comment">// there never was a strong-reference, so we can try to             </span>
            <span class="comment">// promote this object; we need to do that atomically.             </span>
            <span class="keyword">while</span> (curCount &gt; <span class="number">0</span>) {
                <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount + <span class="number">1</span>,
                        &amp;<span class="keyword">impl</span>-&gt;mStrong) == <span class="number">0</span>) {
                    <span class="keyword">break</span>;
                }
                <span class="comment">// the strong count has changed on us, we need to re-assert our</span>
                <span class="comment">// situation (e.g.: another thread has inc/decStrong'ed us)</span>
                curCount = <span class="keyword">impl</span>-&gt;mStrong;
            }

            <span class="keyword">if</span> (curCount &lt;= <span class="number">0</span>) {                 
                <span class="comment">// promote() failed, some other thread destroyed us in the                 </span>
                <span class="comment">// meantime (i.e.: strong count reached zero).                 </span>
                decWeak(id);                 
                <span class="keyword">return</span> <span class="keyword">false</span>;             
            }         
        } <span class="keyword">else</span> {     
            <span class="comment">// this object has an "extended" life-time, i.e.: it can be             </span>
            <span class="comment">// revived from a weak-reference only.             </span>
            <span class="comment">// Ask the object's implementation if it agrees to be revived             </span>
            <span class="keyword">if</span> (!<span class="keyword">impl</span>-&gt;mBase-&gt;onIncStrongAttempted(FIRST_INC_STRONG, id)) {
                <span class="comment">// it didn't so give-up.</span>
                decWeak(id);
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
            <span class="comment">// grab a strong-reference, which is always safe due to the</span>
            <span class="comment">// extended life-time.</span>
            curCount = android_atomic_inc(&amp;<span class="keyword">impl</span>-&gt;mStrong);
        }

        <span class="comment">// If the strong reference count has already been incremented by</span>
        <span class="comment">// someone else, the implementor of onIncStrongAttempted() is holding</span>
        <span class="comment">// an unneeded reference.  So call onLastStrongRef() here to remove it.</span>
        <span class="comment">// (No, this is not pretty.)  Note that we MUST NOT do this if we</span>
        <span class="comment">// are in fact acquiring the first reference.</span>
        <span class="keyword">if</span> (curCount &gt; <span class="number">0</span> &amp;&amp; curCount &lt; INITIAL_STRONG_VALUE) {             
            <span class="keyword">impl</span>-&gt;mBase-&gt;onLastStrongRef(id);
        }
    }
    <span class="comment">// now we need to fix-up the count if it was INITIAL_STRONG_VALUE</span>
    <span class="comment">// this must be done safely, i.e.: handle the case where several threads</span>
    <span class="comment">// were here in attemptIncStrong().</span>
    curCount = <span class="keyword">impl</span>-&gt;mStrong;
    <span class="keyword">while</span> (curCount &gt;= INITIAL_STRONG_VALUE) {
        ALOG_ASSERT(curCount &gt; INITIAL_STRONG_VALUE,
                <span class="string">"attemptIncStrong in %p underflowed to INITIAL_STRONG_VALUE"</span>,
                this);
        <span class="keyword">if</span> (android_atomic_cmpxchg(curCount, curCount-INITIAL_STRONG_VALUE,
                &amp;<span class="keyword">impl</span>-&gt;mStrong) == <span class="number">0</span>) {
            <span class="keyword">break</span>;
        }
        <span class="comment">// the strong-count changed on us, we need to re-assert the situation,</span>
        <span class="comment">// for e.g.: it's possible the fix-up happened in another thread.</span>
        curCount = <span class="keyword">impl</span>-&gt;mStrong;
    }

    <span class="keyword">return</span> <span class="keyword">true</span>;
}
</code></pre><p>首先调用incWeak来增加mWeak计数，因为这里需要获取sp指针，在sp的构造函数我们知道，会同时增加mWeak和mStrong值。然后根据mStong值分两种情况讨论：</p>
<p>1.目标对象正在被其它强指针引用，即它的强引用计数大于0，并且不等于INITIAL_STRONG_VALUE，这时候说明目标对象一定存在，因此，是可以将这个弱指针提升为强指针的，在这种情况下，只要简单地增加目标对象的强引用计数值就行了。<br>2.目标对象没有被任何强指针引用，即它的强引用计数小于等于0，或者等于INITIAL_STRONG_VALUE，这时候目标对象可能还存在，也可能不存了，需要结合Flag去判断。又分为以下几种情况：</p>
<ul>
<li>Flag = OBJECT_LIFETIME_STRONG，并且curCount等于0。说明之前的sp对象已经释放，由前面的知识我们知道，在释放sp对象的同时也会释放原始对象，所以这里调用decWeak来释放前面增加的一次mWeak值并返回false。</li>
</ul>
<ul>
<li>Flag = OBJECT_LIFETIME_STRONG，并且curCount = INITIAL_STRONG_VALUE，说明前面没有sp引用，原始对象是一定存在的，这时我们可以增加mStrong值。</li>
</ul>
<ul>
<li>Flag = OBJECT_LIFETIME_WEAK，这时候由于目标对象正在被弱指针引用，因此，弱引用计数一定不为0，目标对象一定存在，需要进一步调用目标对象的onIncStrongAttempted来看看是否允许这种情况发生，目标对象的设计者可能本身就不希望这个对象被强指针引用，只能通过弱指针来引用它，因此，这里它就可以重载其父类的onIncStrongAttempted函数，然后返回false，这样就可以阻止弱指针都被提升为强指针。在RefBase类中，其成员函数onIncStrongAttempted默认是返回true的。于是增加mStrong值。</li>
</ul>
<p>当上面任何一种情况增加了mStrong值以后，mSrong的值可能大于INITIAL_STRONG_VALUE，也就是原来mSrong是从初始值INITIAL_STRONG_VALUE加上去的。我们需要去修正mStrong，就是通过减去INITIAL_STRONG_VALUE计算。<br>当attemptIncStrong返回true时，promote方法就会调用sp的set_pointer方法去设置StrongPointer中的实际A对象的指针。接下来就可以通过sp调用相关的方法了。</p>
<p>参考文章：<br><a href="http://blog.csdn.net/luoshengyang/article/details/6786239" target="_blank" rel="external">http://blog.csdn.net/luoshengyang/article/details/6786239</a><br><a href="http://blog.csdn.net/lilian0118/article/details/23662383" target="_blank" rel="external">http://blog.csdn.net/lilian0118/article/details/23662383</a></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2015-05-09-e8a7a3e586b3-android-studio-e697a0e6b395e69bb4e696b0e79a84e997aee9a298" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/09/2015-05-09-e8a7a3e586b3-android-studio-e697a0e6b395e69bb4e696b0e79a84e997aee9a298/" class="article-date">
  	<time datetime="2015-05-08T19:46:35.000Z" itemprop="datePublished">2015-05-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/09/2015-05-09-e8a7a3e586b3-android-studio-e697a0e6b395e69bb4e696b0e79a84e997aee9a298/">解决 Android Studio Android SDK 无法更新的问题</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>再次感谢(f@ck)伟大(caodan)的GFW，给程序员带来一次又一次的惊喜(难题)。</p>
<p>Android Studio正式版发布后，它已经逐渐成为android平台的软件开发的主流工具了。</p>
<p>首先我们要下载 Android Studio ，有翻墙工具的可以不用往下看了。</p>
<p>如果没有翻墙工具，可以去这里下载：</p>
<pre><code><span class="string">https:</span><span class="comment">//github.com/inferjay/AndroidDevTools</span>
</code></pre><p>也可以是这里</p>
<pre><code><span class="string">http:</span><span class="comment">//www.androiddevtools.cn/</span>
</code></pre><p>非常方便的网站，妈妈再也不用担心我下不到android开发的资源了。</p>
<p>下载完最新的Android Studio兴致勃勃地去打开它却发现了这个</p>
<pre><code>unable to access Android SDK<span class="instruction"> add-on </span>list
</code></pre><p><img src="http://dylangao.qiniudn.com/error.png" alt=""></p>
<p>没关系，我们去刚才的神网站下载最新的SDK Tools，然后解压到本地。</p>
<p>进入 android studio 安装目录下的bin目录下，在idea.properties文件末尾添加：</p>
<pre><code>disable<span class="class">.android</span><span class="class">.first</span><span class="class">.run</span>=true
</code></pre><p>保存后再次打开就可以顺利进入了。但是SDK Manager选项是灰色的。</p>
<p>依次进入：Configure -&gt; Project Defaults -&gt; Project Structure，</p>
<p>在Android SDK location选择刚才下载的SDK Tools的解压目录，JDK location选择你的JDK的目录，</p>
<p><img src="http://dylangao.qiniudn.com/sdk_setup.png" alt=""></p>
<p>返回到最初的界面，SDK Manager选项已经可以使用了。</p>
<p><img src="http://dylangao.qiniudn.com/sdk_done.png" alt=""></p>
<p>进入SDK Manager，选择Tools-&gt;Options，选择以下代理中速度最快的那个吧：</p>
<pre><code>中国科学院开源协会镜像站地址:
IPV4<span class="regexp">/IPV6: http:/</span>/mirrors.opencas.cn 端口：<span class="number">80</span>
IPV4<span class="regexp">/IPV6: http:/</span>/mirrors.opencas.org 端口：<span class="number">80</span>
IPV4<span class="regexp">/IPV6: http:/</span>/mirrors.opencas.ac.cn 端口：<span class="number">80</span>

上海GDG镜像服务器地址:
<span class="string">http:</span><span class="comment">//sdk.gdgshanghai.com 端口：8000</span>

北京化工大学镜像服务器地址:
<span class="string">IPv4:</span> <span class="string">http:</span><span class="comment">//ubuntu.buct.edu.cn/ 端口：80</span>
<span class="string">IPv4:</span> <span class="string">http:</span><span class="comment">//ubuntu.buct.cn/ 端口：80</span>
<span class="string">IPv6:</span> <span class="string">http:</span><span class="comment">//ubuntu.buct6.edu.cn/ 端口：80</span>

大连东软信息学院镜像服务器地址:
<span class="string">http:</span><span class="comment">//mirrors.neusoft.edu.cn 端口：80</span>
</code></pre><p><img src="http://dylangao.qiniudn.com/proxy.png" alt=""></p>
<p>每次重新设置代理后，记得依次选择Packages-&gt;Reload使之生效。</p>
<p>然后就去享受飞一般的下载速度吧～</p>
<p><img src="http://dylangao.qiniudn.com/download.png" alt=""></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2015-02-11-ps4e585a5e6898be4b880e591a8e6849fe683b3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/11/2015-02-11-ps4e585a5e6898be4b880e591a8e6849fe683b3/" class="article-date">
  	<time datetime="2015-02-10T22:30:21.000Z" itemprop="datePublished">2015-02-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/11/2015-02-11-ps4e585a5e6898be4b880e591a8e6849fe683b3/">PS4入手一周感想</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>PS4入手也有一周多了，这一周玩的也算不少了，来谈一下感想。</p>
<p>入手PSV是在12年年底，其实还是很喜欢PSV的，画面好手感好，中文游戏丰富，可惜就是销量和游戏大作太少了。</p>
<p>整天关注电玩新闻，关注各种电玩展，PSV基本都是在打酱油。次时代的主角是PS4 X1 掌机的赢家的3DS。所以对于PS4心里一直都是痒痒的。</p>
<p>痒了一年后终于决定买了。感谢老婆帮我自提，上午下单，中午老婆就近去实体店自提，晚上我想就应该能玩上了吧。下面是当时的开箱图，当时很激动～</p>
<p><img src="http://dylangao.qiniudn.com/C360_2015-02-02-19-21-07-594.jpg" alt=""><img src="http://dylangao.qiniudn.com/C360_2015-02-02-19-21-41-500.jpg" alt=""></p>
<p>买的是港版白色的，虽然贵了一点点，但是白色真的很好看啊。</p>
<p>之前一直有办PlayStation Plus会员，PSV上积累了很多游戏了，PS4也存了不少游戏。所以我提前一天下载好了所有的游戏文件，本来想着晚上用替换大法，用不了多久就能玩上了。</p>
<p>可惜现实总是残酷的。我花了一晚上时间都没有能登录上我的PSN帐号，根本没法玩啊。感觉自从国行推迟发布那次事件之后，包括我的PSV，在晚上基本就没法登录PSN了，早上倒还可以。</p>
<p>所以第二天早上我起了个早，登上PSN，总算把游戏装上了。。。。。。</p>
<p>买之前我很担心一个问题，因为我没有电视，显示器还是DVI的接口，PS4是HDMI输出，虽然HDMI转DVI的方案有很多，但是担心出什么意外。后来发现这个担心完全是多余的。我只用了买显卡时随机送的一个HDMI转DVI的转接口就完美1080P输出了。就是这个神器。</p>
<p><img src="http://dylangao.qiniudn.com/C360_2015-02-02-13-15-08-740.jpg" alt=""></p>
<p>显示器另外一个接口本来就接的电脑的VGA输出，显示器上一个按键可以切换DVI和VGA，这样可以PS4和PC两不误了。</p>
<p><img src="http://dylangao.qiniudn.com/C360_2015-02-03-08-47-46-610.jpg" alt=""></p>
<p>原来为了解决成本，想着手柄接耳机作为声音输出，后来觉得实在是太不方便了，不能用音箱很不舒服，然后另一个神器登场了，60块钱的光纤音频输出转换器，音频输出也完美解决了。</p>
<p><img src="http://dylangao.qiniudn.com/C360_2015-02-08-15-19-39-104.jpg" alt=""></p>
<p>关于游戏，坑爹长宽没法联机游戏，目前只能玩单机了。画面没得说，很强，就是玩大型游戏风扇的声音有些大。</p>
<p>[embed]<a href="http://v.youku.com/v_show/id_XODg4MTYwODQw.html[/embed" target="_blank" rel="external">http://v.youku.com/v_show/id_XODg4MTYwODQw.html[/embed</a>]</p>
<p>再上几张两图</p>
<p><img src="http://dylangao.qiniudn.com/C360_2015-02-08-15-19-47-121.jpg" alt=""><img src="http://dylangao.qiniudn.com/C360_2015-02-08-15-23-18-228.jpg" alt=""></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/生活/">生活</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PS4/">PS4</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2015-01-06-e5a682e4bd95e4b88be8bdbd-cyanogenmod-e6ba90e4bba3e7a081" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/06/2015-01-06-e5a682e4bd95e4b88be8bdbd-cyanogenmod-e6ba90e4bba3e7a081/" class="article-date">
  	<time datetime="2015-01-05T23:23:00.000Z" itemprop="datePublished">2015-01-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/06/2015-01-06-e5a682e4bd95e4b88be8bdbd-cyanogenmod-e6ba90e4bba3e7a081/">如何下载 CyanogenMod 源代码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>cm12马上要发布了，支持的机型也越来越多，心里痒痒的～想把 CyanogenMod 的代码sync下来，之前尝试过很多次，都失败了，fuck GFW</p>
<p>本来sync代码是一件十分简单的事情，按照官方wiki，只需要：</p>
<pre><code>&lt;<span class="preprocessor">code</span>&gt;repo init -u https://github.com/CyanogenMod/<span class="keyword">android.git </span>-<span class="keyword">b </span>cm-<span class="number">12</span>.<span class="number">0</span>&lt;/<span class="preprocessor">code</span>&gt;




&lt;<span class="preprocessor">code</span>&gt;repo sync&lt;/<span class="preprocessor">code</span>&gt;
</code></pre><p>就好了，感谢伟大(cao dan)的GFW，让这一项简单的工作变得有趣(jian ao)起来。</p>
<p>首先，sync最新的CyanogenMod源码需要最新的repo，否则你init时会遇到莫名其妙的错误，比如：</p>
<pre><code><span class="string">fatal:</span> manifest <span class="string">'default.xml'</span> not available
<span class="string">fatal:</span> duplicate project CyanogenMod<span class="regexp">/android_hardware_qcom_audio in /</span>home<span class="regexp">/dylangao/</span>SourceCode<span class="regexp">/CyanogenMod/</span>.repo<span class="regexp">/manifests/</span><span class="keyword">default</span>.xml
</code></pre><p>找到你的repo，作出以下修改：</p>
<pre><code><span class="setting">REPO_URL = <span class="value"><span class="string">'https://github.com/android/tools_repo.git'</span></span></span>
</code></pre><p>还好Git没有被墙，要不怎么活！！</p>
<p>repo好了，就可以init了</p>
<pre><code>&lt;<span class="preprocessor">code</span>&gt;repo init -u https://github.com/CyanogenMod/<span class="keyword">android.git </span>-<span class="keyword">b </span>cm-<span class="number">12</span>.<span class="number">0</span>&lt;/<span class="preprocessor">code</span>&gt;
</code></pre><p>然后因为AOSP被墙了，还需要将.repo/manifest.xml中的</p>
<pre><code>&lt;remote  <span class="property">name</span>=<span class="string">"aosp"</span>
    fetch=<span class="string">".."</span>
    review=<span class="string">"https://android-review.googlesource.com/"</span> /&gt;
</code></pre><p>改为下面的code即可：</p>
<pre><code>&lt;remote  <span class="property">name</span>=<span class="string">"aosp"</span>
    fetch=<span class="string">"git://aosp.tuna.tsinghua.edu.cn/android/"</span>
    review=<span class="string">"https://android-review.googlesource.com/"</span> /&gt;
</code></pre><p>然后开始sync吧，注意线程数不要高开，默认即可</p>
<pre><code>&lt;<span class="preprocessor">code</span>&gt;repo sync&lt;/<span class="preprocessor">code</span>&gt;
</code></pre>
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2014-12-05-android-e4b88ae7bd91e6b581e9878fe7bb9fe8aea1e79a84e8aebee8aea1e4b88ee5ae9ee78eb0-e8aebee8aea1e7af87" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/05/2014-12-05-android-e4b88ae7bd91e6b581e9878fe7bb9fe8aea1e79a84e8aebee8aea1e4b88ee5ae9ee78eb0-e8aebee8aea1e7af87/" class="article-date">
  	<time datetime="2014-12-05T04:13:44.000Z" itemprop="datePublished">2014-12-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/05/2014-12-05-android-e4b88ae7bd91e6b581e9878fe7bb9fe8aea1e79a84e8aebee8aea1e4b88ee5ae9ee78eb0-e8aebee8aea1e7af87/">Android 上网流量统计的设计与实现-设计篇</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_前言">1. 前言</h2><p>需要做一个 流量统计 的功能，主要实现WIFI和移动数据的日流量统计、月流量统计，可能的话还有流量超限报警等功能。然后着手搜集资料，发现android的SDK提供了类TrafficStats可以获取流量统计值。但是这个类只能获取开机以来的各种流量数据。TrafficStats获取流量数值的实现，是通过JNI，读取并解析linux的proc下相应的文件得到的，关机之后，这些数据都清零了。因此要实现日流量统计、月流量统计，需要借助于数据库等其他手段保存流量数据。</p>
<p>但是，我们可以发现android的Setting里面也集成了流量统计的功能，而且得到的流量信息十分详细，甚至包括某个时间段内每个应用的流量信息。看了Setting的代码，发现其实现借助了NetworkStatsService。但是android的SDK中没有开放这些API，所以应用层的开发只能用TrafficStats类了。</p>
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      
        <p class="article-more-link">
          <a  href="/2014/12/05/2014-12-05-android-e4b88ae7bd91e6b581e9878fe7bb9fe8aea1e79a84e8aebee8aea1e4b88ee5ae9ee78eb0-e8aebee8aea1e7af87/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2014-09-03-dlopen-e59ca8linux-cce794a8e6b395e8afa6e8a7a3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/03/2014-09-03-dlopen-e59ca8linux-cce794a8e6b395e8afa6e8a7a3/" class="article-date">
  	<time datetime="2014-09-03T00:51:00.000Z" itemprop="datePublished">2014-09-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/03/2014-09-03-dlopen-e59ca8linux-cce794a8e6b395e8afa6e8a7a3/">dlopen 在Linux C/C++用法详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文汇总了几篇讲解 dlopen 用法的文章，详细解析dlopen系列函数在Linux C/C++中的使用。</p>
<h2 id="1-dlopen系列API">1.dlopen系列API</h2><p>Linux提供了一套API来动态装载库。这些API包括</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span>
<span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flag)</span></span>;
<span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>;
<span class="function"><span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;
</code></pre><p>下面分别解释这几个函数。</p>
<h3 id="dlopen">dlopen</h3><p>dlopen()函数以指定模式打开指定的动态链接库文件，并返回动态链接库的句柄。参数flag有以下两种常用的值，并且必须指定其一。<br>RTLD_LAZY:在dlopen返回前，对于动态库中存在的未定义的变量(如外部变量extern，也可以是函数)不执行解析，就是不解析这个变量的地址。<br>RTLD_NOW：与上面不同，他需要在dlopen返回前，解析出每个未定义变量的地址，如果解析不出来，在dlopen会返回NULL.</p>
<h3 id="dlsym">dlsym</h3><p>dlsym()函数根据动态链接库操作句柄(handle)与符号(symbol)，返回符号对应的地址。使用这个函数不但可以获取函数地址，也可以获取变量地址。参数的含义如下:<br>handle：由dlopen打开动态链接库后返回的指针；<br>symbol：要求获取的函数或全局变量的名称。</p>
<h3 id="dlclose">dlclose</h3><p>dlclose()函数用于关闭指定句柄的动态链接库，只有当此动态链接库的使用计数为0时,才会真正被系统卸载。</p>
<h3 id="dlerror">dlerror</h3><p>当动态链接库操作函数,如dlopen/dlsym/dlclose//执行失败时，dlerror()函数可以返回最近的出错信息，返回值为NULL时表示操作函数执行成功。</p>
<p>C语言用户需要包含头文件dlfcn.h才能使用上述API。</p>
<h2 id="2-dlopen函数在C语言中的使用">2.dlopen函数在C语言中的使用</h2><p>下面通过一个简单的例子来示范dlopen函数在C语言中的使用。<br>首先是动态库的源代码</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span>
</span>{
    <span class="built_in">printf</span>(<span class="string">"hello\n"</span>);
}
</code></pre><p>可执行文件的源代码，代码中会动态加载so库</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{
    <span class="keyword">void</span> *handle;
    <span class="keyword">void</span> (*callfun) ();
    <span class="keyword">char</span> *error;
    handle = dlopen(<span class="string">"./hello.so"</span>, RTLD_LAZY);

    <span class="keyword">if</span> (!handle) {
        <span class="built_in">printf</span>(<span class="string">"%s \n"</span>, dlerror());
        <span class="built_in">exit</span>(<span class="number">1</span>);
    }
    dlerror();
    callfun = dlsym(handle, <span class="string">"hello"</span>);
    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) {
        <span class="built_in">printf</span>(<span class="string">"%s \n"</span>, error);
        <span class="built_in">exit</span>(<span class="number">1</span>);
    }
    callfun();
    dlclose(handle);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>编译命令：</p>
<pre><code>gcc -fPIC -shared -o hello<span class="class">.so</span> hello<span class="class">.c</span>
gcc -o main main<span class="class">.c</span> -ldl
</code></pre><p>执行：<br>./main<br>就能看到结果</p>
<h2 id="3-dlopen与constructor/destructor">3.dlopen与constructor/destructor</h2><p>dlopen的man page里面有提到。在一些旧的代码中可能会用到两个特殊的函数：_init和_fini。<br>_init和_fini函数用在装载和卸载某个模块时分别控制该模块的构造器和析构器(或构造函数和析构函数)。他们的C语言原型如下：</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">_fini</span><span class="params">(<span class="keyword">void</span>)</span></span>;
</code></pre><p>当一个库通过dlopen()动态打开或以共享库的形式打开时，如果_init在该库中存在且被输出出来，则_init函数会被调用。如果一个库通过dlclose()动态关闭或因为没有应用程序引用其符号而被卸载时，_fini函数会在库卸载前被调用。当使用你自己的_init和_fini函数时，需要注意不要与系统启动文件一起链接。可以使用GCC选项 -nostartfiles做到这一点。但是，使用上面的函数或GCC的-nostartfiles选项并不是很好的习惯，因为这可能会产生一些意外的结果。相反，库应该使用<strong>attribute</strong> ((constructor))和<strong>attribute</strong> ((destructor))函数属性来输出它的构造函数和析构函数。如下所示：</p>
<pre><code>void __attribute__ ((<span class="function"><span class="keyword">constructor</span>)) <span class="title">x_init</span><span class="params">(void)</span>
<span class="title">void</span> __<span class="title">attribute__</span> <span class="params">((<span class="keyword">destructor</span>)</span>) <span class="title">x_fini</span><span class="params">(void)</span></span>
</code></pre><p>构造函数会在dlopen()返回前或库被装载时调用。析构函数会在这样几种情况下被调用：dlclose()返回前，或main()返回后，或装载库过程中exit()被调用时。下面用一个例子来说明。<br>动态库的代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span>

<span class="comment">/* GCC __attribute__ */</span>
<span class="keyword">void</span> __attribute__ ((constructor)) Double_init() {
    <span class="built_in">printf</span>(<span class="string">"_init invoked!\n"</span>);
}

<span class="keyword">void</span> __attribute__ ((destructor)) Double_fini() {
    <span class="built_in">printf</span>(<span class="string">"_fini invoked!\n"</span>);
}

<span class="comment">/* Customized routines here */</span>
<span class="function"><span class="keyword">int</span> <span class="title">Double</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>{
    <span class="keyword">return</span> (arg + arg);
}
</code></pre><p>主程序的代码如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>{
    <span class="keyword">void</span> *handle;
    <span class="keyword">int</span> (*func) (<span class="keyword">int</span>);
    <span class="keyword">const</span> <span class="keyword">char</span> *error;

    <span class="comment">/* shared object (1) */</span>
    handle = dlopen(<span class="string">"./share.so"</span>, RTLD_NOW);
    <span class="keyword">if</span> (!handle) {
        <span class="built_in">fputs</span>(dlerror(), <span class="built_in">stderr</span>);
        <span class="built_in">exit</span>(<span class="number">1</span>);
    }
    func = dlsym(handle, <span class="string">"Double"</span>);
    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) {
        <span class="built_in">fputs</span>(error, <span class="built_in">stderr</span>);
        <span class="built_in">exit</span>(<span class="number">1</span>);
    }
    <span class="built_in">printf</span>(<span class="string">"invoking Double(2) =&gt; %d\n"</span>, (*func) (<span class="number">2</span>));
    dlclose(handle);
}
</code></pre><p>编译命令：</p>
<pre><code>gcc -fPIC -shared -o share<span class="class">.so</span> hello<span class="class">.c</span>
gcc -o main main<span class="class">.c</span> -ldl
</code></pre><p>执行：<br>./main<br>就能看到结果</p>
<h2 id="4-dlopen函数在C++语言中的使用">4.dlopen函数在C++语言中的使用</h2><p>在C语言中，加载一个库轻而易举（调用dlopen、dlsym和dlclose就够了），但对C++来说，情况稍微复杂。动态加载一个C++库的困难一部分是因为C++的name mangling，另一部分是因为dlopen API是用C语言实现的，因而没有提供一个合适的方式来装载C++类。<br>在解释如何装载C++库之前，最好再详细了解一下name mangling。我推荐您了解一下它，即使您对它不感兴趣。因为这有助于您理解问题是如何产生的，如何才能解决它们。</p>
<h3 id="4-1_Name_Mangling">4.1 Name Mangling</h3><p>在每个C++程序（或库、目标文件）中，所有非静态（non-static）函数在二进制文件中都是以“符号（symbol）”形式出现的。这些符号都是唯一的字符串，从而把各个函数在程序、库、目标文件中区分开来。在C中，符号名正是函数名：strcpy函数的符号名就是“strcpy”，等等。这可能是因为两个非静态函数的名字一定各不相同的缘故。而C++允许重载（不同的函数有相同的名字但不同的参数），并且有很多C所没有的特性──比如类、成员函数、异常说明──几乎不可能直接用函数名作符 号名。为了解决这个问题，C++采用了所谓的name mangling。它把函数名和一些信息（如参数数量和大小）杂糅在一起，改造成奇形怪状，只有编译器才懂的符号名。例如，被mangle后的foo可能 看起来像foo@4%6^，或者，符号名里头甚至不包括“foo”。其中一个问题是，C++标准（目前是[ISO14882]）并没有定义名字必须如何被mangle，所以每个编译器都按自己的方式来进行name mangling。有些编译器甚至在不同版本间更换mangling算法（尤其是g++ 2.x和3.x）。即使您搞清楚了您的编译器到底怎么进行mangling的，从而可以用dlsym调用函数了，但可能仅仅限于您手头的这个编译器而已，而无法在下一版编译器下工作。</p>
<h3 id="4-2_类">4.2 类</h3><p>使用dlopen API的另一个问题是，它只支持加载函数。但在C++中，您可能要用到库中的一个类，而这需要创建该类的一个实例，这不容易做到。</p>
<h3 id="4-3_解决方案">4.3 解决方案</h3><h4 id="4-3-1_extern_“C”">4.3.1 extern “C”</h4><p>C++有个特定的关键字用来声明采用C binding的函数：extern “C” 。 用 extern “C”声明的函数将使用函数名作符号名，就像C函数一样。因此，只有非成员函数才能被声明为extern “C”，并且不能被重载。尽管限制多多，extern “C”函数还是非常有用，因为它们可以象C函数一样被dlopen动态加载。冠以extern “C”限定符后，并不意味着函数中无法使用C++代码了，相反，它仍然是一个完全的C++函数，可以使用任何C++特性和各种类型的参数。</p>
<h4 id="4-3-2_加载函数">4.3.2 加载函数</h4><p>在C++中，函数用dlsym加载，就像C中一样。不过，该函数要用extern “C”限定符声明以防止其符号名被mangle。<br>示例1.加载函数<br>代码:</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{
    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;
    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cerr</span>;

    <span class="built_in">cout</span> &lt;&lt; <span class="string">"C++ dlopen demo\n\n"</span>;

    <span class="comment">// open the library</span>
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Opening hello.so...\n"</span>;
    <span class="keyword">void</span> *handle = dlopen(<span class="string">"./hello.so"</span>, RTLD_LAZY);

    <span class="keyword">if</span> (!handle) {
        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Cannot open library: "</span> &lt;&lt; dlerror() &lt;&lt; <span class="string">'\n'</span>;
        <span class="keyword">return</span> <span class="number">1</span>;
    }
    <span class="comment">// load the symbol</span>
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Loading symbol hello...\n"</span>;
    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*hello_t)</span> <span class="params">()</span></span>;
    <span class="keyword">hello_t</span> hello = (<span class="keyword">hello_t</span>) dlsym(handle, <span class="string">"hello"</span>);
    <span class="keyword">if</span> (!hello) {
        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Cannot load symbol 'hello': "</span> &lt;&lt; dlerror() &lt;&lt; <span class="string">'\n'</span>;
        dlclose(handle);
        <span class="keyword">return</span> <span class="number">1</span>;
    }
    <span class="comment">// use it to do the calculation</span>
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling hello...\n"</span>;
    hello();

    <span class="comment">// close the library</span>
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Closing library...\n"</span>;
    dlclose(handle);
}




<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>

<span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span>
</span>{
    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="string">'\n'</span>;
}
</code></pre><p>在hello.cpp中函数hello被定义为extern “C”。它在main.cpp中被dlsym调用。函数必须以extern “C”限定，否则我们无从知晓其符号名。</p>
<p>编译命令：</p>
<pre><code>g++ -fPIC -shared -o hello<span class="class">.so</span> hello<span class="class">.cpp</span>
g++ -o main main<span class="class">.cpp</span> -ldl
</code></pre><p>运行<br>./main<br>可以看到结果。</p>
<h4 id="4-3-3_加载类">4.3.3 加载类</h4><p>加载类有点困难，因为我们需要类的一个实例，而不仅仅是一个函数指针。我们无法通过new来创建类的实例，因为类不是在可执行文件中定义的，况且（有时候）我们连它的名字都不知道。解决方案是：利用多态性！ 我们在可执行文件中定义一个带虚成员函数的接口基类，而在模块中定义派生实现类。通常来说，接口类是抽象的（如果一个类含有虚函数，那它就是抽象的）。因为动态加载类往往用于实现插件，这意味着必须提供一个清晰定义的接口──我们将定义一个接口类和派生实现类。接下来，在模块中，我们会定义两个附加的helper函数，就是众所周知的“类工厂函数（class factory functions）（译者注：或称对象工厂函数）”。其中一个函数创建一个类实例，并返回其指针; 另一个函数则用以销毁该指针。这两个函数都以extern “C”来限定修饰。为了使用模块中的类，我们用dlsym像示例1中加载hello函数那样加载这两个函数，然后我们就可以随心所欲地创建和销毁实例了。</p>
<p>我们用一个一般性的多边形类作为接口，而继承它的三角形类（译者注：正三角形类）作为实现。<br>主文件代码</p>
<pre><code><span class="comment">//----------</span>
<span class="comment">//main.cpp:</span>
<span class="comment">//----------</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">"polygon.h"</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{
    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;
    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cerr</span>;

    <span class="comment">// load the triangle library</span>
    <span class="keyword">void</span> *triangle = dlopen(<span class="string">"./triangle.so"</span>, RTLD_LAZY);
    <span class="keyword">if</span> (!triangle) {
        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Cannot load library: "</span> &lt;&lt; dlerror() &lt;&lt; <span class="string">'\n'</span>;
        <span class="keyword">return</span> <span class="number">1</span>;
    }
    <span class="comment">// reset errors</span>
    dlerror();

    <span class="comment">// load the symbols</span>
    <span class="keyword">create_t</span> *create_triangle = (<span class="keyword">create_t</span> *) dlsym(triangle, <span class="string">"create"</span>);
    <span class="keyword">const</span> <span class="keyword">char</span> *dlsym_error = dlerror();
    <span class="keyword">if</span> (dlsym_error) {
        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Cannot load symbol create: "</span> &lt;&lt; dlsym_error &lt;&lt; <span class="string">'\n'</span>;
        <span class="keyword">return</span> <span class="number">1</span>;
    }

    <span class="keyword">destroy_t</span> *destroy_triangle = (<span class="keyword">destroy_t</span> *) dlsym(triangle, <span class="string">"destroy"</span>);
    dlsym_error = dlerror();
    <span class="keyword">if</span> (dlsym_error) {
        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Cannot load symbol destroy: "</span> &lt;&lt; dlsym_error &lt;&lt; <span class="string">'\n'</span>;
        <span class="keyword">return</span> <span class="number">1</span>;
    }
    <span class="comment">// create an instance of the class</span>
    polygon *poly = create_triangle();

    <span class="comment">// use the class</span>
    poly-&gt;set_side_length(<span class="number">7</span>);
    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The area is: "</span> &lt;&lt; poly-&gt;area() &lt;&lt; <span class="string">'\n'</span>;

    <span class="comment">// destroy the class</span>
    destroy_triangle(poly);

    <span class="comment">// unload the triangle library</span>
    dlclose(triangle);
}
</code></pre><p>polygon接口类头文件</p>
<pre><code><span class="comment">//----------</span>
<span class="comment">//polygon.hpp:</span>
<span class="comment">//----------</span>
<span class="preprocessor">#<span class="keyword">ifndef</span> POLYGON_HPP</span>
<span class="preprocessor">#<span class="keyword">define</span> POLYGON_HPP</span>

<span class="keyword">class</span> polygon {
  <span class="keyword">protected</span>:
    <span class="keyword">double</span> side_length_;

  <span class="keyword">public</span>:
    polygon():side_length_(<span class="number">0</span>) {} 
    <span class="keyword">virtual</span> ~ polygon() {}

    <span class="function"><span class="keyword">void</span> <span class="title">set_side_length</span><span class="params">(<span class="keyword">double</span> side_length)</span> </span>{
        side_length_ = side_length;
    }

    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;
};

<span class="comment">// the types of the class factories</span>
<span class="function"><span class="keyword">typedef</span> polygon *<span class="title">create_t</span><span class="params">()</span></span>;
<span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">destroy_t</span><span class="params">(polygon *)</span></span>;

<span class="preprocessor">#<span class="keyword">endif</span></span>
</code></pre><p>triangle实现类库文件</p>
<pre><code><span class="comment">//----------</span>
<span class="comment">//triangle.cpp:</span>
<span class="comment">//----------</span>
<span class="preprocessor">#include "polygon.h"</span>
<span class="preprocessor">#include &lt;cmath&gt;</span>

<span class="keyword">class</span> <span class="title">triangle</span>:<span class="title">public</span> <span class="title">polygon</span> {
  <span class="keyword">public</span>:
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">area</span>(<span class="params"></span>) <span class="keyword">const</span> </span>{
        <span class="keyword">return</span> side_length_ * side_length_ * sqrt(<span class="number">3</span>) / <span class="number">2</span>;
    }
};

<span class="comment">// the class factories</span>
<span class="keyword">extern</span> <span class="string">"C"</span> polygon * create() {
    <span class="keyword">return</span> <span class="keyword">new</span> triangle;
}

<span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">destroy</span>(<span class="params">polygon * p</span>) </span>{
    delete p;
}
</code></pre><p>编译命令：</p>
<pre><code>g++ -fPIC -shared -o triangle<span class="class">.so</span> polygon<span class="class">.h</span> triangle<span class="class">.cpp</span>
g++ -o main2 main1<span class="class">.cpp</span> polygon<span class="class">.h</span> -ldl
</code></pre><p>运行<br>./main2<br>可以看到结果</p>
<p>加载类时有一些值得注意的地方：<br>◆ 你必须在模块或者说共享库中同时提供一个创造函数和一个销毁函数，且不能在执行文件内部使用delete来销毁实例，只能把实例指针传递给模 块的销毁函数处理。这是因为C++里头，new操作符可以被重载;这容易导致new-delete的不匹配调用，造成莫名其妙的内存泄漏和段错误。这在用不同的标准库链接模块和可执行文件时也一样。<br>◆ 接口类的析构函数在任何情况下都必须是虚函数（virtual）。因为即使出错的可能极小，近乎杞人忧天了，但仍旧不值得去冒险，反正额外的开销微不足道。如果基类不需要析构函数，定义一个空的（但必须虚的）析构函数吧，否则你迟早要遇到问题，我向您保证。你可以在comp.lang.c++ FAQ( <a href="http://www.parashift.com/c++-faq-lite/" target="_blank" rel="external">http://www.parashift.com/c++-faq-lite/</a> )的第20节了解到更多关于该问题的信息。</p>
<h2 id="参考文章：">参考文章：</h2><p><a href="http://blog.chinaunix.net/uid-10540984-id-3508235.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-10540984-id-3508235.html</a><br><a href="http://www.cnblogs.com/leaven/archive/2011/01/28/1947180.html" target="_blank" rel="external">http://www.cnblogs.com/leaven/archive/2011/01/28/1947180.html</a><br><a href="http://www.faqs.org/docs/Linux-mini/C++-dlopen.html" target="_blank" rel="external">http://www.faqs.org/docs/Linux-mini/C++-dlopen.html</a><br><a href="http://www.linuxjournal.com/article.php?sid=3687" target="_blank" rel="external">http://www.linuxjournal.com/article.php?sid=3687</a><br><a href="http://linux.die.net/man/3/dlopen" target="_blank" rel="external">http://linux.die.net/man/3/dlopen</a><br><a href="http://beyond99.blog.51cto.com/1469451/737840" target="_blank" rel="external">http://beyond99.blog.51cto.com/1469451/737840</a><br><a href="http://blog.linux.org.tw/~jserv/archives/001561.html" target="_blank" rel="external">http://blog.linux.org.tw/~jserv/archives/001561.html</a></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2014-08-28-e8a7a3e586b3adbe8bf9ee68ea5e8aebee5a487e587bae78eb0error-insufficient-permissions-for-devicee79a84e99499e8afaf" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/08/28/2014-08-28-e8a7a3e586b3adbe8bf9ee68ea5e8aebee5a487e587bae78eb0error-insufficient-permissions-for-devicee79a84e99499e8afaf/" class="article-date">
  	<time datetime="2014-08-27T22:30:00.000Z" itemprop="datePublished">2014-08-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/28/2014-08-28-e8a7a3e586b3adbe8bf9ee68ea5e8aebee5a487e587bae78eb0error-insufficient-permissions-for-devicee79a84e99499e8afaf/">解决adb连接设备出现error: insufficient permissions for device的错误</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Ubuntu上以普通用户运行adb shell命令，可能会遇到以下错误：</p>
<pre><code>dylangao<span class="variable">@dylangao</span><span class="symbol">:~T|</span>⇒  adb shell
<span class="symbol">error:</span> insufficient permissions <span class="keyword">for</span> device
dylangao<span class="variable">@dylangao</span><span class="symbol">:~T|</span>⇒  adb devices
<span class="constant">List </span>of devices attached
????????????    no permissions
</code></pre><p>这可能是因为普通用户默认对USB设备没有访问权限造成的。这时可以切换到root下运行</p>
<pre><code>root<span class="variable">@dylangao</span><span class="symbol">:~T|</span>⇒  adb kill-server
root<span class="variable">@dylangao</span><span class="symbol">:~T|</span>⇒  adb start-server
daemon <span class="keyword">not</span> running. starting it now on port <span class="number">5037</span> *
daemon started successfully *
</code></pre><p>然后执行adb devices</p>
<pre><code>root<span class="variable">@dylangao</span><span class="symbol">:~T|</span>⇒  adb devices
<span class="constant">List </span>of devices attached
<span class="number">01234567</span>89ABCDEFdevice
</code></pre><p>这时退出root用户再执行adb devices也是OK的。当然也可以直接在普通用户下加sudo执行以上命令</p>
<pre><code>dylangao<span class="variable">@dylangao</span><span class="symbol">:~T|</span>⇒ sudo adb kill-server
dylangao<span class="variable">@dylangao</span><span class="symbol">:~T|</span>⇒ sudo adb start-server
</code></pre><p>以上基本都是临时的解决方法，要从根本上解决，就要让普通用户也取得对USB设备的访问权限。</p>
<p>可以通过给adb命令加上s权限，让adb以root权限运行（关于suid可以参考 <a href="http://www.cnblogs.com/fhefh/archive/2011/09/20/2182155.html）" target="_blank" rel="external">http://www.cnblogs.com/fhefh/archive/2011/09/20/2182155.html）</a></p>
<pre><code>dylangao<span class="variable">@dylangao</span><span class="symbol">:~T/tools|</span>⇒  sudo chmod a+s adb
</code></pre><p>也可以修改/etc/udev/rules.d/51-android.rules，如果没有就手动添加此文件。</p>
<pre><code>dylangao@dylangao:~T|⇒  lsusb
Bus <span class="number">001</span> Device <span class="number">002</span>: ID <span class="number">8087</span>:<span class="number">0024</span> Intel Corp. Integrated Rate Matching Hub
Bus <span class="number">002</span> Device <span class="number">002</span>: ID <span class="number">8087</span>:<span class="number">0024</span> Intel Corp. Integrated Rate Matching Hub
Bus <span class="number">003</span> Device <span class="number">002</span>: ID <span class="number">067</span>b:<span class="number">2303</span> Prolific Technology, Inc. PL2303 Serial Port
Bus <span class="number">003</span> Device <span class="number">101</span>: ID <span class="number">15</span>eb:<span class="number">1105</span>
Bus <span class="number">003</span> Device <span class="number">004</span>: ID <span class="number">03f</span>0:<span class="number">0024</span> Hewlett-Packard KU-<span class="number">0316</span> Keyboard
Bus <span class="number">001</span> Device <span class="number">001</span>: ID <span class="number">1</span>d6b:<span class="number">0002</span> Linux Foundation <span class="number">2.0</span> root hub
Bus <span class="number">002</span> Device <span class="number">001</span>: ID <span class="number">1</span>d6b:<span class="number">0002</span> Linux Foundation <span class="number">2.0</span> root hub
Bus <span class="number">003</span> Device <span class="number">001</span>: ID <span class="number">1</span>d6b:<span class="number">0002</span> Linux Foundation <span class="number">2.0</span> root hub
Bus <span class="number">004</span> Device <span class="number">001</span>: ID <span class="number">1</span>d6b:<span class="number">0003</span> Linux Foundation <span class="number">3.0</span> root hub
Bus <span class="number">001</span> Device <span class="number">006</span>: ID <span class="number">067</span>b:<span class="number">2303</span> Prolific Technology, Inc. PL2303 Serial Port
Bus <span class="number">001</span> Device <span class="number">005</span>: ID <span class="number">148f</span>:<span class="number">760</span>b Ralink Technology, Corp.
Bus <span class="number">001</span> Device <span class="number">004</span>: ID <span class="number">046</span>d:c077 Logitech, Inc.
</code></pre><p>可以看到USB设备的 “ID 15eb:1105”，然后</p>
<pre><code>dylangao<span class="variable">@dylangao</span><span class="symbol">:~T|</span>⇒  cd /etc/udev/rules.d/
dylangao<span class="variable">@dylangao</span><span class="symbol">:/etc/udev/rules</span>.d|⇒  sudo vim <span class="number">51</span>-android.rules
</code></pre><p>添加以下内容：</p>
<pre><code><span class="keyword">SUBSYSTEM=="usb", </span><span class="preprocessor">ATTR</span>{idVendor}==<span class="string">"15eb"</span>, MODE=<span class="string">"0666"</span>, GROUP=<span class="string">"plugdev"</span>
</code></pre><p>然后修改权限</p>
<pre><code>dylangao<span class="variable">@dylangao</span><span class="symbol">:/etc/udev/rules</span>.d|⇒  sudo chmod a+r /etc/udev/rules.d/<span class="number">51</span>-android.rules
</code></pre><p>具体可以参考：<a href="http://developer.android.com/tools/device.html。重新插拔USB设备即可。" target="_blank" rel="external">http://developer.android.com/tools/device.html。重新插拔USB设备即可。</a></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-2014-05-16-android-debuggerd-e7ae80e8a681e4bb8be7bb8de5928ce6ba90e7a081e58886e69e90" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/05/16/2014-05-16-android-debuggerd-e7ae80e8a681e4bb8be7bb8de5928ce6ba90e7a081e58886e69e90/" class="article-date">
  	<time datetime="2014-05-16T01:46:13.000Z" itemprop="datePublished">2014-05-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/16/2014-05-16-android-debuggerd-e7ae80e8a681e4bb8be7bb8de5928ce6ba90e7a081e58886e69e90/">Android Debuggerd 简要介绍和源码分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文以android4.1为基础，分析debuggerd这个工具的使用方法和源码。</p>
<h2 id="1-Debuggerd_简介">1.Debuggerd 简介</h2><p>debuggerd是一个daemon进程，在系统启动时随着init进程启动。主要负责将进程运行时的信息dump到文件或者控制台中。</p>
<h3 id="1-1_debuggerd的运行原理">1.1 debuggerd的运行原理</h3><ul>
<li>创建一个名为 “Android:debuggerd”的socket，作为server端等待其他client端进程的连接</li>
</ul>
<ul>
<li>接收client端进程发送来的tid和action信息</li>
</ul>
<ul>
<li>将由tid指定的那个进程的运行信息，按照由action指定的动作dump到文件或者控制台中</li>
</ul>
<p>可以作为debuggerd的client端的进程主要有几种：</p>
<ul>
<li>异常的C/C++程序</li>
</ul>
<p>这种程序由bionic的linker安装异常信号的处理函数，当程序产生异常信号时，进入信号处理函数，与debuggerd建立。</p>
<ul>
<li>debuggerd程序</li>
</ul>
<p>debuggerd可以在控制台中以命令debuggerd -b [<tid>]启动 ，然后与debuggerd daemon建立连接。这样debuggerd可以在不中断进程执行的情况下dump由tid指定的进程的信息。</p>
<ul>
<li>callstack/dumpstate</li>
</ul>
<p>控制台中运行命令callstack/dumpstate，并指定必要的参数，命令中会调用dump_backtrace_to_file与debuggerd交互<br>
      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

      
        <p class="article-more-link">
          <a  href="/2014/05/16/2014-05-16-android-debuggerd-e7ae80e8a681e4bb8be7bb8de5928ce6ba90e7a081e58886e69e90/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2015 Dylan Gao
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
        </div>
    </div>
    <div class="visit">
      <span id="busuanzi_container_site_pv" style='display:none'>
        <span id="site-visit" >本站到访数: 
        <span id="busuanzi_value_site_uv"></span>
        </span>
      </span>
      <span id="busuanzi_container_page_pv" style='display:none'>
        <span id="page-visit">, 本页阅读量: 
        <span id="busuanzi_value_page_pv"></span>
        </span>
      </span>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

<script type="text/javascript">
  var backgroundList = ["url(/background/bg-1.jpg)", "url(/background/bg-2.jpg)","url(/background/bg-3.jpg)","url(/background/bg-4.jpg)","url(/background/bg-5.jpg)"];
  var background = Math.floor(Math.random() * backgroundList.length);
  $("body").css({"background": backgroundList[background], "background-attachment": "fixed", "background-size": "cover"});
</script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
<a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
<a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>